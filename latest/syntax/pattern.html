<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Pattern Matching &#8212; MLStyle.jl Documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="canonical" href="https://thautwarm.github.io/MLStyle.jl/latest/syntax/pattern.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The Switch Statements" href="switch.html" />
    <link rel="prev" title="Algebraic Data Types" href="adt.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>

  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default ">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          MLStyle.jl</a>
        <span class="navbar-text navbar-version pull-left"><b>latest</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="https://github.com/thautwarm/MLStyle.jl">GitHub</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">MLStyle.jl <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../what.html">What is MLStyle.jl?</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../what.html#motivations">Motivations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../why.html">Why use MLStyle.jl?</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../why.html#straightforward">Straightforward</a></li>
<li class="toctree-l2"><a class="reference internal" href="../why.html#performance-gain">Performance Gain</a></li>
<li class="toctree-l2"><a class="reference internal" href="../why.html#extensibility">Extensibility</a></li>
<li class="toctree-l2"><a class="reference internal" href="../why.html#referential-transparency">Referential Transparency</a></li>
<li class="toctree-l2"><a class="reference internal" href="../why.html#intuition-of-ast-manipulations">Intuition of AST Manipulations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../how.html">Installation, Documentations and Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preview.html">Preview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../preview.html#rock-paper-scissors">Rock Paper Scissors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../preview.html#homoiconic-pattern-matching-for-julia-asts">Homoiconic pattern matching for Julia ASTs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../preview.html#generalized-algebraic-data-types">Generalized Algebraic Data Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../preview.html#active-patterns">Active Patterns</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../benchmark.html">Benchmark</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../benchmark.html#arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../benchmark.html#tuples">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../benchmark.html#data-types">Data Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../benchmark.html#extracting-struct-definitions">Extracting Struct Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../benchmark.html#misc">Misc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../benchmark.html#an-example-from-match-jl-documentation">An Example from Match.jl Documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../contribute.html">Contributing to MLStyle</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="adt.html">Algebraic Data Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="adt.html#basic-constructors">Basic constructors</a><ul>
<li class="toctree-l3"><a class="reference internal" href="adt.html#specifying-field-names">Specifying field names</a></li>
<li class="toctree-l3"><a class="reference internal" href="adt.html#specifying-field-names-and-types">Specifying field names and types</a></li>
<li class="toctree-l3"><a class="reference internal" href="adt.html#subtyping">Subtyping</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="adt.html#less-familiar">Less familiar</a><ul>
<li class="toctree-l3"><a class="reference internal" href="adt.html#singleton-instances">Singleton instances</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="adt.html#cheat-sheet">Cheat Sheet</a></li>
<li class="toctree-l2"><a class="reference internal" href="adt.html#examples">Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="adt.html#example-modeling-arithmetic-operations">Example: Modeling Arithmetic Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="adt.html#about-type-parameters">About Type Parameters</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Pattern Matching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#literal-patterns">Literal Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#capturing-patterns">Capturing Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#type-patterns">Type Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#if-patterns"><code class="docutils literal notranslate"><span class="pre">if</span></code> patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#guardby-patterns"><code class="docutils literal notranslate"><span class="pre">GuardBy</span></code> patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#and-patterns">And-Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#destructuring-tuples-arrays-and-dictionaries-with-pattern-matching">Destructuring Tuples, Arrays, and Dictionaries with Pattern Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="#deconstruction-of-custom-composite-data">Deconstruction of Custom Composite Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#range-patterns">Range Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reference-patterns">Reference Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#macro-call-patterns">Macro Call Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#custom-patterns">Custom Patterns</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#support-pattern-matching-for-julia-enums">Support Pattern Matching for Julia Enums</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pattern-synonyms">Pattern Synonyms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#or-patterns">Or Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#advanced-type-patterns">Advanced Type Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#active-patterns">Active Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#expr-patterns">Expr Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#julia-code-as-expr-patterns">Julia Code as Expr Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#advanced-do-patterns-many-patterns">Advanced: Do-Patterns &amp; Many-Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#advanced-let-patterns">Advanced: Let Patterns</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="switch.html">The Switch Statements</a></li>
<li class="toctree-l1"><a class="reference internal" href="records.html">Records</a></li>
<li class="toctree-l1"><a class="reference internal" href="when.html">When Destructuring</a><ul>
<li class="toctree-l2"><a class="reference internal" href="when.html#allow-destructuring-in-let-binding">Allow Destructuring in Let-Binding</a></li>
<li class="toctree-l2"><a class="reference internal" href="when.html#sole-destructuring">Sole Destructuring</a></li>
<li class="toctree-l2"><a class="reference internal" href="when.html#multiple-branches">Multiple Branches</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pattern-function.html">Pattern Functions</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules/ast.html">MLStyle.Modules.AST</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../modules/ast.html#matchast">&#64;matchast</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/ast.html#capture"><code class="docutils literal notranslate"><span class="pre">Capture</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/ast.html#capture-1">&#64;capture</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../modules/cond.html">MLStyle.Modules.Cond</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../modules/cond.html#cond">&#64;cond</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/capture.html">Static Capturing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/capture.html#capture-pattern-from-mlstyle-modules-ast"><code class="docutils literal notranslate"><span class="pre">Capture</span></code> Pattern from <code class="docutils literal notranslate"><span class="pre">MLStyle.Modules.AST</span></code>:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/capture.html#raii-style">RAII-Style</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Structure <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Pattern Matching</a><ul>
<li><a class="reference internal" href="#literal-patterns">Literal Patterns</a></li>
<li><a class="reference internal" href="#capturing-patterns">Capturing Patterns</a></li>
<li><a class="reference internal" href="#type-patterns">Type Patterns</a></li>
<li><a class="reference internal" href="#if-patterns"><code class="docutils literal notranslate"><span class="pre">if</span></code> patterns</a></li>
<li><a class="reference internal" href="#guardby-patterns"><code class="docutils literal notranslate"><span class="pre">GuardBy</span></code> patterns</a></li>
<li><a class="reference internal" href="#and-patterns">And-Patterns</a></li>
<li><a class="reference internal" href="#destructuring-tuples-arrays-and-dictionaries-with-pattern-matching">Destructuring Tuples, Arrays, and Dictionaries with Pattern Matching</a></li>
<li><a class="reference internal" href="#deconstruction-of-custom-composite-data">Deconstruction of Custom Composite Data</a></li>
<li><a class="reference internal" href="#range-patterns">Range Patterns</a></li>
<li><a class="reference internal" href="#reference-patterns">Reference Patterns</a></li>
<li><a class="reference internal" href="#macro-call-patterns">Macro Call Patterns</a></li>
<li><a class="reference internal" href="#custom-patterns">Custom Patterns</a><ul>
<li><a class="reference internal" href="#support-pattern-matching-for-julia-enums">Support Pattern Matching for Julia Enums</a></li>
<li><a class="reference internal" href="#pattern-synonyms">Pattern Synonyms</a></li>
</ul>
</li>
<li><a class="reference internal" href="#or-patterns">Or Patterns</a></li>
<li><a class="reference internal" href="#advanced-type-patterns">Advanced Type Patterns</a></li>
<li><a class="reference internal" href="#active-patterns">Active Patterns</a></li>
<li><a class="reference internal" href="#expr-patterns">Expr Patterns</a></li>
<li><a class="reference internal" href="#julia-code-as-expr-patterns">Julia Code as Expr Patterns</a></li>
<li><a class="reference internal" href="#advanced-do-patterns-many-patterns">Advanced: Do-Patterns &amp; Many-Patterns</a></li>
<li><a class="reference internal" href="#advanced-let-patterns">Advanced: Let Patterns</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="adt.html" title="Previous Chapter: Algebraic Data Types"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; Algebraic Data T...</span>
    </a>
  </li>
  <li>
    <a href="switch.html" title="Next Chapter: The Switch Statements"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">The Switch State... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <section id="pattern-matching">
<h1>Pattern Matching<a class="headerlink" href="#pattern-matching" title="Permalink to this headline">¶</a></h1>
<p>Pattern matching provides convenient ways to manipulate data. The basic syntax for pattern matching with MLStyle is of the form</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@match</span> <span class="nv">data</span> <span class="k">begin</span>
    <span class="nv">pattern1</span> <span class="o">=&gt;</span> <span class="nv">result1</span>
    <span class="nv">pattern2</span> <span class="o">=&gt;</span> <span class="nv">result2</span>
    <span class="p">...</span>
    <span class="nv">patternn</span> <span class="o">=&gt;</span> <span class="nv">resultn</span>
<span class="k">end</span>
</pre></div>
</div>
<p>MLStyle will first test if <code class="docutils literal notranslate"><span class="pre">data</span></code> is matched by <code class="docutils literal notranslate"><span class="pre">pattern1</span></code> and if it does match, return <code class="docutils literal notranslate"><span class="pre">result1</span></code>. If <code class="docutils literal notranslate"><span class="pre">pattern1</span></code> does not match, then MLStyle moves on to the next pattern in sequence. If no pattern in the list matches <code class="docutils literal notranslate"><span class="pre">data</span></code>, an error is thrown.</p>
<p>In version 0.4.1 and newer, if you only have a single pattern you may instead write</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@match</span> <span class="nv">data</span> <span class="nv">pattern</span> <span class="o">=&gt;</span> <span class="nv">result</span>
</pre></div>
</div>
<p>without the block syntax.</p>
<section id="literal-patterns">
<h2>Literal Patterns<a class="headerlink" href="#literal-patterns" title="Permalink to this headline">¶</a></h2>
<p>Patterns with a literal (e.g. <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">false</span></code>, <code class="docutils literal notranslate"><span class="pre">nothing</span></code>, <code class="docutils literal notranslate"><span class="pre">4.0</span></code>, <code class="docutils literal notranslate"><span class="pre">1f-6</span></code>, etc) on the left hand side will check if the the argument is equal to that literal:</p>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="m">10</span> <span class="k">begin</span>
           <span class="m">1</span>  <span class="o">=&gt;</span> <span class="s">&quot;wrong!&quot;</span>
           <span class="m">2</span>  <span class="o">=&gt;</span> <span class="s">&quot;wrong!&quot;</span>
           <span class="m">10</span> <span class="o">=&gt;</span> <span class="s">&quot;right!&quot;</span>
       <span class="k">end</span>
<span class="s">&quot;right!&quot;</span>
</pre></div>
</div>
<p>You can think of this match expression like</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nv">VALUE</span> <span class="o">=</span> <span class="m">10</span>
<span class="k">if</span> <span class="nv">VALUE</span> <span class="o">===</span> <span class="m">1</span>
    <span class="s">&quot;wrong!&quot;</span>
<span class="k">elseif</span> <span class="nv">VALUE</span> <span class="o">===</span> <span class="m">2</span>
    <span class="s">&quot;wrong!&quot;</span>
<span class="k">elseif</span> <span class="nv">VALUE</span> <span class="o">===</span> <span class="m">10</span>
    <span class="s">&quot;right!&quot;</span>
<span class="k">else</span>
    <span class="nb">error</span><span class="p">(</span><span class="s">&quot;matching non-exhaustive&quot;</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>All literal data introduced with Julia syntax can be matched by literal patterns. However, matching with exact <code class="docutils literal notranslate"><span class="pre">===</span></code> equality is required only for primitive types (<code class="docutils literal notranslate"><span class="pre">Int8-64</span></code>, <code class="docutils literal notranslate"><span class="pre">UInt8-64</span></code>, <code class="docutils literal notranslate"><span class="pre">Bool</span></code>, etc.) and singleton types (e.g. <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Data</span> <span class="pre">end;</span> <span class="pre">Data()</span></code>). Other types may match more flexibly: for example, a <code class="docutils literal notranslate"><span class="pre">SubString</span></code> can match a literal string pattern; a single integer value like <code class="docutils literal notranslate"><span class="pre">3</span></code> can match a range pattern like <code class="docutils literal notranslate"><span class="pre">1:5</span></code> that contains it.</p>
</section>
<section id="capturing-patterns">
<h2>Capturing Patterns<a class="headerlink" href="#capturing-patterns" title="Permalink to this headline">¶</a></h2>
<p>A pattern where there is a symbol such as <code class="docutils literal notranslate"><span class="pre">x</span></code> on the left hand side will bind the input value to that symbol and let you use that captured value on the right hand side:</p>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="m">1</span> <span class="k">begin</span>
           <span class="nv">x</span> <span class="o">=&gt;</span> <span class="nv">x</span> <span class="o">+</span> <span class="m">1</span>
       <span class="k">end</span>
<span class="m">2</span>
</pre></div>
</div>
<p>This match expression is like</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nv">VALUE</span> <span class="o">=</span> <span class="m">1</span>
<span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="nv">VALUE</span>
    <span class="nv">x</span> <span class="o">+</span> <span class="m">1</span>
<span class="k">end</span>
</pre></div>
</div>
<p>You can put <code class="docutils literal notranslate"><span class="pre">_</span></code> on the left hand side of a pattern if you don’t care about what the captured value is.</p>
<p>However, sometimes a symbol might not be used for capturing. If and only if some visible global variable <code class="docutils literal notranslate"><span class="pre">x</span></code> satisfying <code class="docutils literal notranslate"><span class="pre">MLStyle.is_enum(x)</span> <span class="pre">==</span> <span class="pre">true</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> is used as an enum pattern.</p>
<p>Check <a class="reference external" href="#custom-patterns">Custom Patterns</a> for details.</p>
</section>
<section id="type-patterns">
<h2>Type Patterns<a class="headerlink" href="#type-patterns" title="Permalink to this headline">¶</a></h2>
<p>Writing <code class="docutils literal notranslate"><span class="pre">::Foo</span></code> on the left hand side of a pattern will match if the input is of type <code class="docutils literal notranslate"><span class="pre">Foo</span></code>. You can conbine this with a literal pattern by writing <code class="docutils literal notranslate"><span class="pre">x::Foo</span></code> which will match inputs of type <code class="docutils literal notranslate"><span class="pre">Foo</span></code> and bind them to a variable <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="m">1</span> <span class="k">begin</span>
           <span class="o">::</span><span class="nb">Float64</span>  <span class="o">=&gt;</span> <span class="k">nothing</span>
           <span class="nv">b</span> <span class="o">::</span> <span class="nb">Int</span> <span class="o">=&gt;</span> <span class="nv">b</span>
           <span class="nv">_</span>        <span class="o">=&gt;</span> <span class="k">nothing</span>
       <span class="k">end</span>
<span class="m">1</span>
</pre></div>
</div>
</section>
<section id="if-patterns">
<h2><code class="docutils literal notranslate"><span class="pre">if</span></code> patterns<a class="headerlink" href="#if-patterns" title="Permalink to this headline">¶</a></h2>
<p>Writing <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">cond</span> <span class="pre">end</span></code> as a pattern will match if <code class="docutils literal notranslate"><span class="pre">cond==true</span></code></p>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="m">1</span><span class="p">.</span><span class="m">0</span> <span class="k">begin</span>
           <span class="k">if</span> <span class="m">1</span> <span class="o">&lt;</span> <span class="m">5</span> <span class="k">end</span>  <span class="o">=&gt;</span> <span class="nv">√</span><span class="p">(</span><span class="m">5</span> <span class="o">-</span> <span class="m">1</span><span class="p">)</span>
       <span class="k">end</span>
<span class="m">2</span><span class="p">.</span><span class="m">0</span>
</pre></div>
</div>
<p>Unlike most ML languages or other libraries which only permit guards at the end of a case clause,
MLStyle.jl allows you to put guards anywhere during matching.</p>
<p>Sometimes, in practice, you might want to introduce type variables into the scope, in this case use <code class="docutils literal notranslate"><span class="pre">where</span></code> clause. See <a class="reference external" href="#advanced-type-patterns">Advanced Type Patterns</a> for more details.</p>
</section>
<section id="guardby-patterns">
<h2><code class="docutils literal notranslate"><span class="pre">GuardBy</span></code> patterns<a class="headerlink" href="#guardby-patterns" title="Permalink to this headline">¶</a></h2>
<p>Equivalent to guard patterns, writing <code class="docutils literal notranslate"><span class="pre">GuardBy(f)</span></code> in a pattern will match if and only if <code class="docutils literal notranslate"><span class="pre">f</span></code> applied to the pattern matching input gives true:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span> <span class="nf">pred</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span>
    <span class="nv">x</span> <span class="o">&gt;</span> <span class="m">5</span>
<span class="k">end</span>

<span class="nd">@match</span> <span class="nv">x</span> <span class="k">begin</span>
    <span class="nf">GuardBy</span><span class="p">(</span><span class="nv">pred</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="m">5</span> <span class="o">-</span> <span class="nv">x</span> <span class="c"># only succeeds when x &gt; 5</span>
    <span class="nv">_</span>        <span class="o">=&gt;</span> <span class="m">1</span>
<span class="k">end</span>

<span class="nd">@match</span> <span class="nv">x</span> <span class="k">begin</span>
    <span class="nf">GuardBy</span><span class="p">(</span><span class="nv">x</span> <span class="o">-&gt;</span> <span class="nv">x</span> <span class="o">&gt;</span> <span class="m">5</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="m">5</span> <span class="o">-</span> <span class="nv">x</span> <span class="c"># only succeeds when x &gt; 5</span>
    <span class="nv">_</span>        <span class="o">=&gt;</span> <span class="m">1</span>
<span class="k">end</span>
</pre></div>
</div>
</section>
<section id="and-patterns">
<h2>And-Patterns<a class="headerlink" href="#and-patterns" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">pat2</span> <span class="pre">&amp;&amp;</span> <span class="pre">pat2</span></code> on the left hand side of a pattern will match if and only if <code class="docutils literal notranslate"><span class="pre">pat1</span></code> and <code class="docutils literal notranslate"><span class="pre">pat2</span></code> match individually. This lets you combine two separate patterns together,</p>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="m">2</span> <span class="k">begin</span>
           <span class="nv">x</span><span class="o">::</span><span class="nb">Int</span> <span class="o">&amp;&amp;</span> <span class="k">if</span> <span class="nv">x</span> <span class="o">&lt;</span> <span class="m">5</span> <span class="k">end</span> <span class="o">=&gt;</span> <span class="nv">√</span><span class="p">(</span><span class="m">5</span> <span class="o">-</span> <span class="nv">x</span><span class="p">)</span>
       <span class="k">end</span>
<span class="m">1</span><span class="p">.</span><span class="m">7320508075688772</span>
</pre></div>
</div>
<ul class="simple">
<li><p>As Pattern</p></li>
</ul>
<p>Writing <code class="docutils literal notranslate"><span class="pre">pat</span> <span class="pre">&amp;&amp;</span> <span class="pre">x</span></code> on the left hand side of a pattern will bind the input to <code class="docutils literal notranslate"><span class="pre">x</span></code> if <code class="docutils literal notranslate"><span class="pre">pat</span></code> matches the input, allowing the input to be used on the right hand side. This is sometimes called an As-Pattern in ML derived languages, but in MLStyle, it is just a subset of the functionality in the And-Pattern</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span> <span class="k">begin</span>
           <span class="p">(</span><span class="nv">a</span><span class="p">,</span> <span class="nv">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nv">c</span> <span class="o">=&gt;</span> <span class="nv">c</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="o">==</span> <span class="nv">a</span> <span class="o">&amp;&amp;</span> <span class="nv">c</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="o">==</span> <span class="nv">b</span>
       <span class="k">end</span>
<span class="k">true</span>
</pre></div>
</div>
</section>
<section id="destructuring-tuples-arrays-and-dictionaries-with-pattern-matching">
<h2>Destructuring Tuples, Arrays, and Dictionaries with Pattern Matching<a class="headerlink" href="#destructuring-tuples-arrays-and-dictionaries-with-pattern-matching" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Tuple Patterns</p></li>
</ul>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="p">(</span><span class="m">5</span><span class="p">,</span> <span class="p">)))</span> <span class="k">begin</span>
           <span class="p">(</span><span class="nv">a</span><span class="p">,</span> <span class="nv">b</span><span class="p">,</span> <span class="p">(</span><span class="nv">c</span><span class="p">,</span> <span class="nv">d</span><span class="p">,</span> <span class="p">(</span><span class="m">5</span><span class="p">,</span> <span class="p">)))</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nv">a</span><span class="p">,</span> <span class="nv">b</span><span class="p">,</span> <span class="nv">c</span><span class="p">,</span> <span class="nv">d</span><span class="p">)</span>
       <span class="k">end</span>
<span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Array Patterns</p></li>
</ul>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nv">it</span> <span class="o">=</span> <span class="nd">@match</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">]</span> <span class="k">begin</span>
         <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="nv">pack</span><span class="p">...,</span> <span class="nv">a</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nv">pack</span><span class="p">,</span> <span class="nv">a</span><span class="p">)</span>
       <span class="k">end</span>
<span class="p">([</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">],</span> <span class="m">4</span><span class="p">)</span>

<span class="gp">julia&gt;</span> <span class="nb">first</span><span class="p">(</span><span class="nv">it</span><span class="p">)</span>
<span class="m">2</span><span class="o">-</span><span class="nv">element</span> <span class="nb">view</span><span class="p">(</span><span class="o">::</span><span class="nb">Array</span><span class="p">{</span><span class="nb">Int64</span><span class="p">,</span><span class="m">1</span><span class="p">},</span> <span class="m">2</span><span class="o">:</span><span class="m">3</span><span class="p">)</span> <span class="nv">with</span> <span class="nv">eltype</span> <span class="nb">Int64</span><span class="o">:</span>
 <span class="m">2</span>
 <span class="m">3</span>
<span class="gp">julia&gt;</span> <span class="nv">it</span><span class="p">[</span><span class="m">2</span><span class="p">]</span>
<span class="m">4</span>

<span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="nb">Int</span><span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">]</span> <span class="k">begin</span>
         <span class="nb">Any</span><span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="o">:</span><span class="nv">a</span>
         <span class="nb">Int</span><span class="p">[</span><span class="nv">_</span><span class="p">,</span> <span class="nv">_</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="o">:</span><span class="nv">b</span>
       <span class="k">end</span>
<span class="o">:</span><span class="nv">b</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Dict pattern(like <code class="docutils literal notranslate"><span class="pre">Elixir</span></code>’s dictionary matching or ML record matching)</p></li>
</ul>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nv">dict</span> <span class="o">=</span> <span class="nb">Dict</span><span class="p">(</span><span class="m">1</span> <span class="o">=&gt;</span> <span class="m">2</span><span class="p">,</span> <span class="s">&quot;3&quot;</span> <span class="o">=&gt;</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span> <span class="o">=&gt;</span> <span class="nb">Dict</span><span class="p">(</span><span class="m">6</span> <span class="o">=&gt;</span> <span class="m">7</span><span class="p">))</span>
<span class="nb">Dict</span><span class="p">{</span><span class="nb">Any</span><span class="p">,</span><span class="nb">Any</span><span class="p">}</span> <span class="nv">with</span> <span class="m">3</span> <span class="nv">entries</span><span class="o">:</span>
  <span class="m">1</span>   <span class="o">=&gt;</span> <span class="m">2</span>
  <span class="m">5</span>   <span class="o">=&gt;</span> <span class="nb">Dict</span><span class="p">(</span><span class="m">6</span><span class="o">=&gt;</span><span class="m">7</span><span class="p">)</span>
  <span class="s">&quot;3&quot;</span> <span class="o">=&gt;</span> <span class="m">4</span>

<span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="nv">dict</span> <span class="k">begin</span>
           <span class="nb">Dict</span><span class="p">(</span><span class="s">&quot;3&quot;</span> <span class="o">=&gt;</span> <span class="nv">four</span><span class="o">::</span><span class="nb">Int</span><span class="p">,</span>
                 <span class="m">5</span>  <span class="o">=&gt;</span> <span class="nb">Dict</span><span class="p">(</span><span class="m">6</span> <span class="o">=&gt;</span> <span class="nv">sev</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="k">if</span> <span class="nv">four</span> <span class="o">&lt;</span> <span class="nv">sev</span> <span class="k">end</span> <span class="o">=&gt;</span> <span class="nv">sev</span>
       <span class="k">end</span>
<span class="m">7</span>
</pre></div>
</div>
<p>Note that, due to the lack of an operation for distinguishing <code class="docutils literal notranslate"><span class="pre">nothing</span></code> from “key not found” in Julia’s standard library, the dictionary pattern has a little overhead. This will be resolved after <a class="reference external" href="https://github.com/JuliaLang/julia/pull/34821">Julia#34821</a> is completed.</p>
<p><strong>P.S</strong>:  MLStyle will not refer an external package to solve this issue, as MLStyle is generating “runtime-support free” code, which means that any code generated by MLStyle itself depends only on Stdlib. This feature allows MLStyle to be introduced as a dependency only in development, instead of being distributed together to downstream users.</p>
</section>
<section id="deconstruction-of-custom-composite-data">
<h2>Deconstruction of Custom Composite Data<a class="headerlink" href="#deconstruction-of-custom-composite-data" title="Permalink to this headline">¶</a></h2>
<p>In order to deconstruct arbitrary data types in a similar way to <code class="docutils literal notranslate"><span class="pre">Tuple</span></code>, <code class="docutils literal notranslate"><span class="pre">Array</span></code> and <code class="docutils literal notranslate"><span class="pre">Dict</span></code>, simply declare them to be record types with the <code class="docutils literal notranslate"><span class="pre">&#64;as_record</span></code> macro.</p>
<p>Here is an example, check more about ADTs(and GADTs) at <a class="reference external" href="https://thautwarm.github.io/MLStyle.jl/latest/syntax/adt">Algebraic Data Type Syntax in MLStyle</a>.</p>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@data</span> <span class="nv">Color</span> <span class="k">begin</span>
         <span class="nf">RGB</span><span class="p">(</span><span class="nv">r</span><span class="o">::</span><span class="nb">Int</span><span class="p">,</span> <span class="nv">g</span><span class="o">::</span><span class="nb">Int</span><span class="p">,</span> <span class="nv">b</span><span class="o">::</span><span class="nb">Int</span><span class="p">)</span>
         <span class="nf">Gray</span><span class="p">(</span><span class="nb">Int</span><span class="p">)</span>
       <span class="k">end</span>

<span class="gp">julia&gt;</span> <span class="c"># treating those types as records for more flexible pattern matching</span>

<span class="gp">julia&gt;</span> <span class="nd">@as_record</span> <span class="nv">RGB</span>

<span class="gp">julia&gt;</span> <span class="nd">@as_record</span> <span class="nv">Gray</span>

<span class="gp">julia&gt;</span> <span class="nf">color_to_int</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="o">=</span> <span class="nd">@match</span> <span class="nv">x</span> <span class="k">begin</span>
           <span class="nf">RGB</span><span class="p">(;</span><span class="nv">r</span><span class="p">,</span> <span class="nv">g</span><span class="p">,</span> <span class="nv">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="m">16</span> <span class="o">+</span> <span class="nv">b</span> <span class="o">+</span> <span class="m">6</span><span class="nv">g</span> <span class="o">+</span> <span class="m">36</span><span class="nv">r</span>
           <span class="nf">Gray</span><span class="p">(</span><span class="nv">i</span><span class="p">)</span>       <span class="o">=&gt;</span> <span class="m">232</span> <span class="o">+</span> <span class="nv">i</span>
       <span class="k">end</span>
<span class="nv">color_to_int</span> <span class="p">(</span><span class="nv">generic</span> <span class="k">function</span> <span class="nv">with</span> <span class="m">1</span> <span class="nv">method</span><span class="p">)</span>

<span class="gp">julia&gt;</span> <span class="nf">RGB</span><span class="p">(</span><span class="m">200</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">200</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="nv">color_to_int</span>
<span class="m">7416</span>

<span class="gp">julia&gt;</span> <span class="nf">Gray</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>         <span class="o">|&gt;</span> <span class="nv">color_to_int</span>
<span class="m">242</span>
</pre></div>
</div>
<p>In the above cases, after <code class="docutils literal notranslate"><span class="pre">&#64;as_record</span> <span class="pre">T</span></code>, we can use something called <a class="reference external" href="https://dev.realworldocaml.org/records.html#field-punning">field punning</a> to match structures very conveniently.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@match</span> <span class="nv">rbg_datum</span> <span class="k">begin</span>
    <span class="nf">RGB</span><span class="p">(;</span><span class="nv">r</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="k">if</span> <span class="nv">r</span> <span class="o">&lt;</span> <span class="m">20</span> <span class="k">end</span> <span class="o">=&gt;</span> <span class="p">...</span>
    <span class="nf">RGB</span><span class="p">(;</span><span class="nv">r</span><span class="p">,</span> <span class="nv">g</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="k">if</span> <span class="m">10</span><span class="nv">r</span> <span class="o">&lt;</span> <span class="nv">g</span> <span class="k">end</span> <span class="o">=&gt;</span> <span class="p">...</span>
    <span class="p">...</span>
<span class="k">end</span>
</pre></div>
</div>
<p>As you can see, field punning can be partial.</p>
</section>
<section id="range-patterns">
<h2>Range Patterns<a class="headerlink" href="#range-patterns" title="Permalink to this headline">¶</a></h2>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="m">1</span> <span class="k">begin</span>
           <span class="m">0</span><span class="o">:</span><span class="m">2</span><span class="o">:</span><span class="m">10</span> <span class="o">=&gt;</span> <span class="m">1</span>
           <span class="m">1</span><span class="o">:</span><span class="m">10</span> <span class="o">=&gt;</span> <span class="m">2</span>
       <span class="k">end</span>
<span class="m">2</span>
</pre></div>
</div>
</section>
<section id="reference-patterns">
<h2>Reference Patterns<a class="headerlink" href="#reference-patterns" title="Permalink to this headline">¶</a></h2>
<p>This feature is known as the <code class="docutils literal notranslate"><span class="pre">pin</span> <span class="pre">operator</span></code> from <code class="docutils literal notranslate"><span class="pre">Elixir</span></code> which can slightly extend ML based pattern matching.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nv">c</span> <span class="o">=</span> <span class="p">...</span>
<span class="nd">@match</span> <span class="p">(</span><span class="nv">x</span><span class="p">,</span> <span class="nv">y</span><span class="p">)</span> <span class="k">begin</span>
    <span class="p">(</span><span class="o">&amp;</span><span class="nv">c</span><span class="p">,</span> <span class="nv">_</span><span class="p">)</span>  <span class="o">=&gt;</span> <span class="s">&quot;x equals to c!&quot;</span>
    <span class="p">(</span><span class="nv">_</span><span class="p">,</span>  <span class="o">&amp;</span><span class="nv">c</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s">&quot;y equals to c!&quot;</span>
    <span class="nv">_</span>        <span class="o">=&gt;</span> <span class="s">&quot;none of x and y equal to c&quot;</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Reference Patterns are useful, for example, when it’s necessary to match on the values of numeric variables, but not the type:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nv">c</span> <span class="o">=</span> <span class="nb">Int16</span><span class="p">(</span><span class="m">10</span><span class="p">)</span> <span class="c"># c is of type Int16</span>

<span class="nd">@match</span> <span class="nv">c</span> <span class="k">begin</span>
    <span class="m">10</span><span class="p">.</span><span class="m">0</span> <span class="o">=&gt;</span> <span class="s">&quot;there is a match&quot;</span> <span class="c"># pattern is a Float</span>
    <span class="nv">_</span>    <span class="o">=&gt;</span> <span class="s">&quot;there is not a match&quot;</span>
<span class="k">end</span> <span class="c"># =&gt; &quot;there is not a match&quot;</span>

<span class="nd">@match</span> <span class="nv">c</span> <span class="k">begin</span>
    <span class="o">&amp;</span><span class="m">10</span><span class="p">.</span><span class="m">0</span> <span class="o">=&gt;</span> <span class="s">&quot;there is a match&quot;</span>
    <span class="nv">_</span>    <span class="o">=&gt;</span> <span class="s">&quot;there is not a match&quot;</span>
<span class="k">end</span> <span class="c"># =&gt; &quot;there is a match&quot;</span>
</pre></div>
</div>
<p>When matching a primitive type or an immutable, size-zero type literal pattern matching behaves with strict equality. This behavior is similar to the <a class="reference external" href="https://docs.julialang.org/en/v1/base/base/#Core.:==="><code class="docutils literal notranslate"><span class="pre">===</span></code></a> operator in base Julia. Reference patterns behave more like the <a class="reference external" href="https://docs.julialang.org/en/v1/base/math/#Base.:=="><code class="docutils literal notranslate"><span class="pre">==</span></code></a> operator in base Julia, where the type of the numeric variable is ignored, and only abstract values are compared.</p>
</section>
<section id="macro-call-patterns">
<h2>Macro Call Patterns<a class="headerlink" href="#macro-call-patterns" title="Permalink to this headline">¶</a></h2>
<p>By default, a macro call appearing in a pattern will be no different from its expanded expression. Hence the following bidirectional relationship <strong>sometimes</strong> holds:</p>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="k">macro</span> <span class="nf">mymacro</span><span class="p">(</span><span class="nv">a</span><span class="p">)</span>
         <span class="nb">esc</span><span class="p">(</span><span class="o">:</span><span class="p">([</span><span class="o">$</span><span class="nv">a</span><span class="p">]))</span>
       <span class="k">end</span>
<span class="nd">@mymacro</span> <span class="p">(</span><span class="k">macro</span> <span class="nv">with</span> <span class="m">1</span> <span class="nv">method</span><span class="p">)</span>

<span class="gp">julia&gt;</span> <span class="nv">a</span> <span class="o">=</span> <span class="m">2</span>
<span class="m">2</span>

<span class="gp">julia&gt;</span> <span class="nv">a</span> <span class="o">==</span> <span class="nd">@match</span> <span class="nd">@mymacro</span><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="k">begin</span>
                <span class="nd">@mymacro</span><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nv">a</span>
            <span class="k">end</span>
<span class="k">true</span>

<span class="c"># expanded form:</span>
<span class="c"># julia&gt; a == @match [a] begin</span>
<span class="c">#                [a] =&gt; a</span>
<span class="c">#            end</span>
</pre></div>
</div>
<p>However, you can also change the pattern compilation behavior by overloading <code class="docutils literal notranslate"><span class="pre">MLStyle.pattern_unmacrocall</span></code>, whose usage can be found at the implementation of the pattern support for <a class="reference external" href="https://github.com/thautwarm/MLStyle.jl/blob/master/src/Pervasives.jl#L191"><code class="docutils literal notranslate"><span class="pre">&#64;r_str</span></code></a>.</p>
<p>Some examples about string macro patterns:</p>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@match</span>  <span class="nv">raw</span><span class="s">&quot;$$$&quot;</span> <span class="k">begin</span>
           <span class="nv">raw</span><span class="s">&quot;$$$&quot;</span> <span class="o">=&gt;</span> <span class="m">1</span>
       <span class="k">end</span>
<span class="m">1</span>

<span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="s">&quot;123&quot;</span> <span class="k">begin</span>
           <span class="sr">r&quot;^\d+$&quot;</span> <span class="o">=&gt;</span> <span class="m">1</span>
       <span class="k">end</span>
<span class="m">1</span>
</pre></div>
</div>
</section>
<section id="custom-patterns">
<h2>Custom Patterns<a class="headerlink" href="#custom-patterns" title="Permalink to this headline">¶</a></h2>
<p>As we’ve suggested in <a class="reference external" href="#capturing-patterns">Capturing-Patterns</a>,
you can always define your own patterns with MLStyle and easily leverge our compiler and optimizer.</p>
<p>You can extend following APIs for your pattern objects, to implement custom patterns:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">MLStyle.pattern_uncall</span></code></p>
<ul>
<li><p>args:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">pat_obj</span></code></p>
<p>your pattern object, should be a global variable in some module. The pattern is visible if and only if the global variable is visible in current scope.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">expr_to_pat::Function</span></code></p>
<p>this is provided for you to transform an AST into patterns, for instance, <code class="docutils literal notranslate"><span class="pre">expr_to_pat(:([a,</span> <span class="pre">1]))</span></code>, with which you create a pattern same as <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">1]</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">type_params</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type_args</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">args</span></code></p></li>
</ul>
</li>
<li><p>usage</p>
<p>We compile the AST <code class="docutils literal notranslate"><span class="pre">pat_obj{c,</span> <span class="pre">d}(e,</span> <span class="pre">f)</span> <span class="pre">where</span> <span class="pre">{a,</span> <span class="pre">b}</span></code> into
the pattern with <code class="docutils literal notranslate"><span class="pre">MLStyle.pattern_uncall(pat_obj,</span> <span class="pre">expr_to_pat,</span> <span class="pre">[:a,</span> <span class="pre">:b],</span> <span class="pre">[:c,</span> <span class="pre">:d],</span> <span class="pre">[:e,</span> <span class="pre">:f])</span></code>.</p>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">MLStyle.pattern_unref</span></code></p>
<ul>
<li><p>args:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pat_obj</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">expr_to_pat</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">args</span></code></p></li>
</ul>
</li>
<li><p>usage</p>
<p>We compile the AST <code class="docutils literal notranslate"><span class="pre">pat_obj[a,</span> <span class="pre">b]</span></code> into patterns with
<code class="docutils literal notranslate"><span class="pre">MLStyle.pattern_unref(pat_obj,</span> <span class="pre">expr_to_pat,</span> <span class="pre">[:a,</span> <span class="pre">:b]</span></code>.</p>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">MLStyle.is_enum</span></code></p>
<p>In a pattern <code class="docutils literal notranslate"><span class="pre">[A,</span> <span class="pre">B]</span></code>, usually we think both <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are capturing patterns. However, it is handy if we can have a pattern <code class="docutils literal notranslate"><span class="pre">A</span></code> whose match means comparing to the global variable <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>To achieve this, we provide <code class="docutils literal notranslate"><span class="pre">MLStyle.is_enum</span></code>.
For a visible global variable <code class="docutils literal notranslate"><span class="pre">A</span></code>, if <code class="docutils literal notranslate"><span class="pre">MLStyle.is_enum(A)</span> <span class="pre">==</span> <span class="pre">true</span></code>, a symbol <code class="docutils literal notranslate"><span class="pre">A</span></code> will compile into a pattern with <code class="docutils literal notranslate"><span class="pre">MLStyle.pattern_uncall(A,</span> <span class="pre">expr_to_ast,</span> <span class="pre">[],</span> <span class="pre">[],</span> <span class="pre">[])</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">MLStyle.enum_matcher(E,</span> <span class="pre">value_to_match)</span></code>:</p>
<p>If <code class="docutils literal notranslate"><span class="pre">MLStyle.is_enum(E)</span> <span class="pre">==</span> <span class="pre">true</span></code>, we will call <code class="docutils literal notranslate"><span class="pre">MLStyle.enum_matcher(E,</span> <span class="pre">value_to_match)</span></code> to compile <code class="docutils literal notranslate"><span class="pre">E</span></code> into a pattern.</p>
</li>
</ul>
<p>We present some examples for understandability:</p>
<section id="support-pattern-matching-for-julia-enums">
<h3>Support Pattern Matching for Julia Enums<a class="headerlink" href="#support-pattern-matching-for-julia-enums" title="Permalink to this headline">¶</a></h3>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="k">using</span> <span class="nv">MLStyle</span>
<span class="gp">julia&gt;</span> <span class="nd">@enum</span> <span class="nv">E</span> <span class="nv">E1</span> <span class="nv">E2</span>
<span class="c"># mark E1, E2 as non-capturing patterns</span>
<span class="gp">julia&gt;</span> <span class="nv">MLStyle</span><span class="p">.</span><span class="nf">is_enum</span><span class="p">(</span><span class="o">::</span><span class="nv">E</span><span class="p">)</span> <span class="o">=</span> <span class="k">true</span>
<span class="c"># tell the compiler how to match E1 and E2</span>
<span class="c"># NOTE: make sure it evaluates to a boolean value!</span>
<span class="gp">julia&gt;</span> <span class="nv">MLStyle</span><span class="p">.</span><span class="nf">enum_matcher</span><span class="p">(</span><span class="nv">e</span><span class="o">::</span><span class="nv">E</span><span class="p">,</span> <span class="nv">expr</span><span class="p">)</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="o">$</span><span class="nv">e</span> <span class="o">===</span> <span class="o">$</span><span class="nv">expr</span><span class="p">)</span>
<span class="gp">julia&gt;</span> <span class="nv">x</span> <span class="o">=</span> <span class="nv">E2</span>
<span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="nv">x</span> <span class="k">begin</span>
           <span class="nv">E1</span> <span class="o">=&gt;</span> <span class="s">&quot;match E1!&quot;</span>
           <span class="nv">E2</span> <span class="o">=&gt;</span> <span class="s">&quot;match E2!&quot;</span>
       <span class="k">end</span>
<span class="s">&quot;match E2!&quot;</span>
<span class="nv">x</span> <span class="o">=</span> <span class="nv">E1</span>
<span class="gp">julia&gt;</span> <span class="nd">@macroexpand</span> <span class="nd">@match</span> <span class="nv">x</span> <span class="k">begin</span>
                  <span class="nv">E1</span> <span class="o">=&gt;</span> <span class="s">&quot;match E1!&quot;</span>
                  <span class="nv">E2</span> <span class="o">=&gt;</span> <span class="s">&quot;match E2!&quot;</span>
        <span class="k">end</span>

<span class="o">:</span><span class="p">(</span><span class="k">let</span>
      <span class="nv">var</span><span class="s">&quot;##return#261&quot;</span> <span class="o">=</span> <span class="k">nothing</span>
      <span class="nv">var</span><span class="s">&quot;##263&quot;</span> <span class="o">=</span> <span class="nv">x</span>
      <span class="k">if</span> <span class="nv">E1</span> <span class="o">===</span> <span class="nv">var</span><span class="s">&quot;##263&quot;</span>
          <span class="nv">var</span><span class="s">&quot;##return#261&quot;</span> <span class="o">=</span> <span class="k">let</span>
                  <span class="s">&quot;match E1!&quot;</span>
              <span class="k">end</span>
          <span class="o">$</span><span class="p">(</span><span class="nb">Expr</span><span class="p">(</span><span class="o">:</span><span class="nv">symbolicgoto</span><span class="p">,</span> <span class="nb">Symbol</span><span class="p">(</span><span class="s">&quot;####final#262#264&quot;</span><span class="p">)))</span>
      <span class="k">end</span>
      <span class="k">if</span> <span class="nv">E1</span> <span class="o">===</span> <span class="nv">var</span><span class="s">&quot;##263&quot;</span>
          <span class="nv">var</span><span class="s">&quot;##return#261&quot;</span> <span class="o">=</span> <span class="k">let</span>
                  <span class="s">&quot;match E2!&quot;</span>
              <span class="k">end</span>
          <span class="o">$</span><span class="p">(</span><span class="nb">Expr</span><span class="p">(</span><span class="o">:</span><span class="nv">symbolicgoto</span><span class="p">,</span> <span class="nb">Symbol</span><span class="p">(</span><span class="s">&quot;####final#262#264&quot;</span><span class="p">)))</span>
      <span class="k">end</span>
      <span class="p">(</span><span class="nv">error</span><span class="p">)(</span><span class="s">&quot;matching non-exhaustive, at #= ... =#&quot;</span><span class="p">)</span>
      <span class="o">$</span><span class="p">(</span><span class="nb">Expr</span><span class="p">(</span><span class="o">:</span><span class="nv">symboliclabel</span><span class="p">,</span> <span class="nb">Symbol</span><span class="p">(</span><span class="s">&quot;####final#262#264&quot;</span><span class="p">)))</span>
      <span class="nv">var</span><span class="s">&quot;##return#261&quot;</span>
<span class="k">end</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="pattern-synonyms">
<h3>Pattern Synonyms<a class="headerlink" href="#pattern-synonyms" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/pattern_synonyms.html">pattern synonyms</a> is a tasty feature in the Haskell programming language for defining patterns based on existing patterns.</p>
<p>Suppose we want to regard <code class="docutils literal notranslate"><span class="pre">Triple</span></code> as a pattern that matches expressions of the form <code class="docutils literal notranslate"><span class="pre">(_,</span> <span class="pre">_,</span> <span class="pre">_)</span></code></p>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="k">struct</span> <span class="nv">Triple</span> <span class="k">end</span>
<span class="gp">julia&gt;</span> <span class="nv">MLStyle</span><span class="p">.</span><span class="nf">pattern_uncall</span><span class="p">(</span><span class="o">::</span><span class="nb">Type</span><span class="p">{</span><span class="nv">Triple</span><span class="p">},</span> <span class="nv">expr_to_ast</span><span class="p">,</span> <span class="nv">_</span><span class="p">,</span> <span class="nv">_</span><span class="p">,</span> <span class="nv">_</span><span class="p">)</span> <span class="o">=</span>
            <span class="nf">expr_to_ast</span><span class="p">(</span><span class="o">:</span><span class="p">(</span>  <span class="p">(</span><span class="nv">_</span><span class="p">,</span> <span class="nv">_</span><span class="p">,</span> <span class="nv">_</span><span class="p">)</span>  <span class="p">))</span>
<span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span> <span class="k">begin</span>
            <span class="nv">Triple</span> <span class="o">=&gt;</span> <span class="s">&quot;triple&quot;</span>
            <span class="nv">_</span> <span class="o">=&gt;</span> <span class="s">&quot;not a triple&quot;</span>
        <span class="k">end</span>

<span class="s">&quot;not a triple&quot;</span>

<span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span> <span class="k">begin</span>
            <span class="nv">Triple</span> <span class="o">=&gt;</span> <span class="s">&quot;triple&quot;</span>
            <span class="nv">_</span> <span class="o">=&gt;</span> <span class="s">&quot;no a triple&quot;</span>
        <span class="k">end</span>

<span class="s">&quot;triple&quot;</span>
</pre></div>
</div>
<p><a class="reference external" href="#active-patterns">Active Patterns</a> and <a class="reference external" href="https://thautwarm.github.io/MLStyle.jl/latest/syntax/adt.html#cheat-sheet">ADTs</a> are implemented via custom patterns.</p>
<p>The custom patterns give us so-called <strong>extensible pattern matching</strong>.</p>
</section>
</section>
<section id="or-patterns">
<h2>Or Patterns<a class="headerlink" href="#or-patterns" title="Permalink to this headline">¶</a></h2>
<p>Writing <code class="docutils literal notranslate"><span class="pre">pat1</span> <span class="pre">||</span> <span class="pre">pat2</span></code> will match if either <code class="docutils literal notranslate"><span class="pre">pat1</span></code> <em>or</em> <code class="docutils literal notranslate"><span class="pre">pat2</span></code> match. If <code class="docutils literal notranslate"><span class="pre">pat1</span></code> matches, MLStyle will not attempt to match <code class="docutils literal notranslate"><span class="pre">pat2</span></code>.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nf">test</span><span class="p">(</span><span class="nv">num</span><span class="p">)</span> <span class="o">=</span>
    <span class="nd">@match</span> <span class="nv">num</span> <span class="k">begin</span>
       <span class="o">::</span><span class="nb">Float64</span> <span class="o">||</span>
        <span class="m">0</span>        <span class="o">||</span>
        <span class="m">1</span>        <span class="o">||</span>
        <span class="m">2</span>        <span class="o">=&gt;</span> <span class="k">true</span>

        <span class="nv">_</span>        <span class="o">=&gt;</span> <span class="k">false</span>
    <span class="k">end</span>

<span class="nf">test</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>   <span class="c"># true</span>
<span class="nf">test</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>   <span class="c"># true</span>
<span class="nf">test</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>   <span class="c"># true</span>
<span class="nf">test</span><span class="p">(</span><span class="m">1</span><span class="p">.</span><span class="m">0</span><span class="p">)</span> <span class="c"># true</span>
<span class="nf">test</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>   <span class="c"># false</span>
<span class="nf">test</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span>  <span class="c"># false</span>
</pre></div>
</div>
<p>Tips: <code class="docutils literal notranslate"><span class="pre">Or</span> <span class="pre">Pattern</span></code>s can be nested.</p>
</section>
<section id="advanced-type-patterns">
<h2>Advanced Type Patterns<a class="headerlink" href="#advanced-type-patterns" title="Permalink to this headline">¶</a></h2>
<p>We can introduce type parameters via <code class="docutils literal notranslate"><span class="pre">where</span></code> syntax.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@match</span> <span class="m">1</span> <span class="k">begin</span>
    <span class="nv">a</span> <span class="o">::</span> <span class="nv">T</span> <span class="nv">where</span> <span class="nv">T</span> <span class="o">=&gt;</span> <span class="nv">T</span>
<span class="k">end</span> <span class="c"># =&gt; Int64</span>
</pre></div>
</div>
<p>However, whenever you’re using <code class="docutils literal notranslate"><span class="pre">where</span></code>, DO NOT use locally captured type arguments in the right side of <code class="docutils literal notranslate"><span class="pre">::</span></code>, when <code class="docutils literal notranslate"><span class="pre">::</span></code> is directly under a <code class="docutils literal notranslate"><span class="pre">where</span></code>.</p>
<p><strong>Wrong use</strong>:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@match</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">))</span> <span class="k">begin</span>
    <span class="p">(</span><span class="o">::</span><span class="nv">T1</span> <span class="nv">where</span> <span class="nv">T1</span><span class="p">,</span> <span class="o">::</span><span class="nb">Tuple</span><span class="p">{</span><span class="nv">T1</span><span class="p">,</span> <span class="nv">T2</span><span class="p">}</span> <span class="nv">where</span> <span class="nv">T2</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nv">T1</span><span class="p">,</span> <span class="nv">T2</span><span class="p">)</span>
<span class="k">end</span>
<span class="c"># T1 not defined</span>
</pre></div>
</div>
<p>Workaround 1:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@match</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">))</span> <span class="k">begin</span>
    <span class="p">(</span><span class="o">::</span><span class="nv">T1</span> <span class="nv">where</span> <span class="nv">T1</span><span class="p">,</span> <span class="o">::</span><span class="nb">Tuple</span><span class="p">{</span><span class="nv">T1′</span><span class="p">,</span> <span class="nv">T2</span><span class="p">}</span> <span class="nv">where</span> <span class="p">{</span><span class="nv">T1′</span><span class="p">,</span> <span class="nv">T2</span><span class="p">})</span> <span class="o">&amp;&amp;</span>
     <span class="k">if</span> <span class="nv">T1′</span> <span class="o">==</span> <span class="nv">T1</span> <span class="k">end</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nv">T1</span><span class="p">,</span> <span class="nv">T2</span><span class="p">)</span>
<span class="k">end</span>
<span class="c"># (Int64, Int64)</span>
</pre></div>
</div>
<p>Workaround 2:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@match</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">))</span> <span class="k">begin</span>
    <span class="p">(</span><span class="o">::</span><span class="nv">T1</span><span class="p">,</span> <span class="p">(</span><span class="o">::</span><span class="nv">T1</span><span class="p">,</span> <span class="o">::</span><span class="nv">T2</span><span class="p">))</span> <span class="o">::</span> <span class="nb">Tuple</span><span class="p">{</span><span class="nv">T1</span><span class="p">,</span> <span class="nb">Tuple</span><span class="p">{</span><span class="nv">T1</span><span class="p">,</span> <span class="nv">T2</span><span class="p">}}</span> <span class="nv">where</span> <span class="p">{</span><span class="nv">T1</span><span class="p">,</span> <span class="nv">T2</span><span class="p">}</span> <span class="o">=&gt;</span>
        <span class="p">(</span><span class="nv">T1</span><span class="p">,</span> <span class="nv">T2</span><span class="p">)</span>
<span class="k">end</span>
<span class="c"># (Int64, Int64)</span>
</pre></div>
</div>
<p>Some other examples:</p>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="m">1</span> <span class="k">begin</span>
           <span class="o">::</span><span class="nv">T</span> <span class="nv">where</span> <span class="nv">T</span> <span class="o">=&gt;</span> <span class="nv">T</span>
       <span class="k">end</span>
<span class="nb">Int64</span>

<span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="m">1</span> <span class="k">begin</span>
           <span class="o">::</span><span class="nv">T</span> <span class="nv">where</span> <span class="nv">T</span> <span class="o">&lt;:</span> <span class="nb">Number</span> <span class="o">=&gt;</span> <span class="nv">T</span>
       <span class="k">end</span>
<span class="nb">Int64</span>

<span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="m">1</span> <span class="k">begin</span>
           <span class="o">::</span><span class="nv">T</span> <span class="nv">where</span> <span class="nv">T</span> <span class="o">&lt;:</span> <span class="nb">AbstractFloat</span> <span class="o">=&gt;</span> <span class="nv">T</span>
       <span class="k">end</span>
<span class="nv">ERROR</span><span class="o">:</span> <span class="nv">matching</span> <span class="nv">non</span><span class="o">-</span><span class="nv">exhaustive</span><span class="p">,</span> <span class="nv">at</span> <span class="cm">#= REPL[n]:1 =#</span>
</pre></div>
</div>
</section>
<section id="active-patterns">
<h2>Active Patterns<a class="headerlink" href="#active-patterns" title="Permalink to this headline">¶</a></h2>
<p>This implementation is a subset of <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/active-patterns">F# Active Patterns</a>. Active patterns let you decompose the input value in a customized way.</p>
<p>There are 3 distinct active patterns, the first of which is the normal form:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="c"># 1-ary deconstruction: return Union{Some{T}, Nothing}</span>
<span class="nd">@active</span> <span class="nf">LessThan0</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span> <span class="nv">x</span> <span class="o">&gt;=</span> <span class="m">0</span>
        <span class="k">nothing</span>
    <span class="k">else</span>
        <span class="nb">Some</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="nd">@match</span> <span class="m">15</span> <span class="k">begin</span>
    <span class="nf">LessThan0</span><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nv">a</span>
    <span class="nv">_</span> <span class="o">=&gt;</span> <span class="m">0</span>
<span class="k">end</span> <span class="c"># 0</span>

<span class="nd">@match</span> <span class="o">-</span><span class="m">15</span> <span class="k">begin</span>
    <span class="nf">LessThan0</span><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nv">a</span>
    <span class="nv">_</span> <span class="o">=&gt;</span> <span class="m">0</span>
<span class="k">end</span> <span class="c"># -15</span>

<span class="c"># 0-ary deconstruction: return Bool</span>
<span class="nd">@active</span> <span class="nf">IsLessThan0</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="k">begin</span>
    <span class="nv">x</span> <span class="o">&lt;</span> <span class="m">0</span>
<span class="k">end</span>

<span class="nd">@match</span> <span class="m">10</span> <span class="k">begin</span>
    <span class="nf">IsLessThan0</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="o">:</span><span class="nv">a</span>
    <span class="nv">_</span> <span class="o">=&gt;</span> <span class="o">:</span><span class="nv">b</span>
<span class="k">end</span> <span class="c"># b</span>

<span class="c"># (n+2)-ary deconstruction: return Tuple{E1, E2, ...}</span>
<span class="nd">@active</span> <span class="nf">SplitVecAt2</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="k">begin</span>
    <span class="p">(</span><span class="nv">x</span><span class="p">[</span><span class="m">1</span><span class="p">:</span><span class="m">2</span><span class="p">],</span> <span class="nv">x</span><span class="p">[</span><span class="m">2</span><span class="p">+</span><span class="m">1</span><span class="p">:</span><span class="nb">end</span><span class="p">])</span>
<span class="k">end</span>

<span class="nd">@match</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">7</span><span class="p">]</span> <span class="k">begin</span>
    <span class="nf">SplitVecAt2</span><span class="p">(</span><span class="nv">a</span><span class="p">,</span> <span class="nv">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nv">a</span><span class="p">,</span> <span class="nv">b</span><span class="p">)</span>
<span class="k">end</span>
<span class="c"># ([1, 2], [3, 4, 7])</span>
</pre></div>
</div>
<p>Above 3 cases can be enhanced by becoming <strong>parametric</strong>:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@active</span> <span class="nv">SplitVecAt</span><span class="p">{</span><span class="nv">N</span><span class="o">::</span><span class="nb">Int</span><span class="p">}(</span><span class="nv">x</span><span class="p">)</span> <span class="k">begin</span>
    <span class="p">(</span><span class="nv">x</span><span class="p">[</span><span class="m">1</span><span class="p">:</span><span class="nv">N</span><span class="p">],</span> <span class="nv">x</span><span class="p">[</span><span class="nv">N</span><span class="p">+</span><span class="m">1</span><span class="p">:</span><span class="nb">end</span><span class="p">])</span>
<span class="k">end</span>

<span class="nd">@match</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">7</span><span class="p">]</span> <span class="k">begin</span>
    <span class="nv">SplitVecAt</span><span class="p">{</span><span class="m">2</span><span class="p">}(</span><span class="nv">a</span><span class="p">,</span> <span class="nv">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nv">a</span><span class="p">,</span> <span class="nv">b</span><span class="p">)</span>
<span class="k">end</span>
<span class="c"># ([1, 2], [3, 4, 7])</span>

<span class="nd">@active</span> <span class="nv">Re</span><span class="p">{</span><span class="nv">r</span> <span class="o">::</span> <span class="nb">Regex</span><span class="p">}(</span><span class="nv">x</span><span class="p">)</span> <span class="k">begin</span>
    <span class="nv">res</span> <span class="o">=</span> <span class="nb">match</span><span class="p">(</span><span class="nv">r</span><span class="p">,</span> <span class="nv">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="nv">res</span> <span class="o">!==</span> <span class="k">nothing</span>
        <span class="c"># use explicit `if-else` to emphasize the return should be Union{T, Nothing}.</span>
        <span class="nb">Some</span><span class="p">(</span><span class="nv">res</span><span class="p">)</span>
    <span class="k">else</span>
        <span class="k">nothing</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="nd">@match</span> <span class="s">&quot;123&quot;</span> <span class="k">begin</span>
    <span class="nv">Re</span><span class="p">{</span><span class="sr">r&quot;\d+&quot;</span><span class="p">}(</span><span class="nv">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nv">x</span>
    <span class="nv">_</span> <span class="o">=&gt;</span> <span class="nd">@error</span> <span class="s">&quot;&quot;</span>
<span class="k">end</span> <span class="c"># RegexMatch(&quot;123&quot;)</span>
</pre></div>
</div>
<p>Sometimes the enum syntax is useful and convenient:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@active</span> <span class="nf">IsEven</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="k">begin</span>
    <span class="nv">x</span> <span class="o">%</span> <span class="m">2</span> <span class="o">===</span> <span class="m">0</span>
<span class="k">end</span>

<span class="nv">MLStyle</span><span class="p">.</span><span class="nf">is_enum</span><span class="p">(</span><span class="o">::</span><span class="nb">Type</span><span class="p">{</span><span class="nv">IsEven</span><span class="p">})</span> <span class="o">=</span> <span class="k">true</span>

<span class="nd">@match</span> <span class="m">6</span> <span class="k">begin</span>
    <span class="nv">IsEven</span> <span class="o">=&gt;</span> <span class="o">:</span><span class="nv">even</span>
    <span class="nv">_</span> <span class="o">=&gt;</span> <span class="o">:</span><span class="nv">odd</span>
<span class="k">end</span> <span class="c"># :even</span>
</pre></div>
</div>
</section>
<section id="expr-patterns">
<h2>Expr Patterns<a class="headerlink" href="#expr-patterns" title="Permalink to this headline">¶</a></h2>
<p>This is mainly for AST manipulations. In fact, another pattern informally called “Ast pattern”, would be translated into Expr patterns.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span> <span class="nf">extract_name</span><span class="p">(</span><span class="nv">e</span><span class="p">)</span>
        <span class="nd">@match</span> <span class="nv">e</span> <span class="k">begin</span>
            <span class="o">::</span><span class="nb">Symbol</span>                           <span class="o">=&gt;</span> <span class="nv">e</span>
            <span class="nb">Expr</span><span class="p">(</span><span class="o">:&lt;:</span><span class="p">,</span> <span class="nv">a</span><span class="p">,</span> <span class="nv">_</span><span class="p">)</span>                    <span class="o">=&gt;</span> <span class="nf">extract_name</span><span class="p">(</span><span class="nv">a</span><span class="p">)</span>
            <span class="nb">Expr</span><span class="p">(</span><span class="o">:</span><span class="k">struct</span><span class="p">,</span> <span class="nv">_</span><span class="p">,</span> <span class="nv">name</span><span class="p">,</span> <span class="nv">_</span><span class="p">)</span>          <span class="o">=&gt;</span> <span class="nf">extract_name</span><span class="p">(</span><span class="nv">name</span><span class="p">)</span>
            <span class="nb">Expr</span><span class="p">(</span><span class="o">:</span><span class="nv">call</span><span class="p">,</span> <span class="nv">f</span><span class="p">,</span> <span class="nv">_</span><span class="p">...)</span>               <span class="o">=&gt;</span> <span class="nf">extract_name</span><span class="p">(</span><span class="nv">f</span><span class="p">)</span>
            <span class="nb">Expr</span><span class="p">(</span><span class="o">:</span><span class="p">.,</span> <span class="nv">subject</span><span class="p">,</span> <span class="nv">attr</span><span class="p">,</span> <span class="nv">_</span><span class="p">...)</span>      <span class="o">=&gt;</span> <span class="nf">extract_name</span><span class="p">(</span><span class="nv">subject</span><span class="p">)</span>
            <span class="nb">Expr</span><span class="p">(</span><span class="o">:</span><span class="k">function</span><span class="p">,</span> <span class="nv">sig</span><span class="p">,</span> <span class="nv">_</span><span class="p">...)</span>         <span class="o">=&gt;</span> <span class="nf">extract_name</span><span class="p">(</span><span class="nv">sig</span><span class="p">)</span>
            <span class="nb">Expr</span><span class="p">(</span><span class="o">:</span><span class="k">const</span><span class="p">,</span> <span class="nv">assn</span><span class="p">,</span> <span class="nv">_</span><span class="p">...)</span>           <span class="o">=&gt;</span> <span class="nf">extract_name</span><span class="p">(</span><span class="nv">assn</span><span class="p">)</span>
            <span class="nb">Expr</span><span class="p">(</span><span class="o">:</span><span class="p">(</span><span class="o">=</span><span class="p">),</span> <span class="nv">fn</span><span class="p">,</span> <span class="nv">body</span><span class="p">,</span> <span class="nv">_</span><span class="p">...)</span>         <span class="o">=&gt;</span> <span class="nf">extract_name</span><span class="p">(</span><span class="nv">fn</span><span class="p">)</span>
            <span class="nb">Expr</span><span class="p">(</span><span class="nv">expr_type</span><span class="p">,</span>  <span class="nv">_</span><span class="p">...)</span>             <span class="o">=&gt;</span> <span class="nb">error</span><span class="p">(</span><span class="s">&quot;Can&#39;t extract name from &quot;</span><span class="p">,</span>
                                                        <span class="nv">expr_type</span><span class="p">,</span> <span class="s">&quot; expression:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                                                        <span class="s">&quot;    </span><span class="si">$e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="k">end</span>
<span class="k">end</span>
<span class="nd">@assert</span> <span class="o">:</span><span class="nv">f</span> <span class="o">==</span> <span class="nf">extract_name</span><span class="p">(</span><span class="o">:</span><span class="p">(</span>
    <span class="k">function</span> <span class="nf">f</span><span class="p">()</span>
        <span class="m">1</span> <span class="o">+</span> <span class="m">1</span>
    <span class="k">end</span>
<span class="p">))</span>
</pre></div>
</div>
</section>
<section id="julia-code-as-expr-patterns">
<h2>Julia Code as Expr Patterns<a class="headerlink" href="#julia-code-as-expr-patterns" title="Permalink to this headline">¶</a></h2>
<p>For convenience I call this “AST pattern”, note it’s not a formal name.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nv">rmlines</span> <span class="o">=</span> <span class="nd">@λ</span> <span class="k">begin</span>
    <span class="nv">e</span> <span class="o">::</span> <span class="nb">Expr</span>           <span class="o">-&gt;</span> <span class="nb">Expr</span><span class="p">(</span><span class="nv">e</span><span class="p">.</span><span class="nv">head</span><span class="p">,</span> <span class="nb">filter</span><span class="p">(</span><span class="nv">x</span> <span class="o">-&gt;</span> <span class="nv">x</span> <span class="o">!==</span> <span class="k">nothing</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="nv">rmlines</span><span class="p">,</span> <span class="nv">e</span><span class="p">.</span><span class="nv">args</span><span class="p">))...)</span>
      <span class="o">::</span> <span class="nb">LineNumberNode</span> <span class="o">-&gt;</span> <span class="k">nothing</span>
    <span class="nv">a</span>                   <span class="o">-&gt;</span> <span class="nv">a</span>
<span class="k">end</span>
<span class="nv">expr</span> <span class="o">=</span> <span class="k">quote</span>
    <span class="k">struct</span> <span class="nv">S</span><span class="p">{</span><span class="nv">T</span><span class="p">}</span>
        <span class="nv">a</span> <span class="o">::</span> <span class="nb">Int</span>
        <span class="nv">b</span> <span class="o">::</span> <span class="nv">T</span>
    <span class="k">end</span>
<span class="k">end</span> <span class="o">|&gt;</span> <span class="nv">rmlines</span>

<span class="nd">@match</span> <span class="nv">expr</span> <span class="k">begin</span>
    <span class="k">quote</span>
        <span class="k">struct</span> <span class="o">$</span><span class="nv">name</span><span class="p">{</span><span class="o">$</span><span class="nv">tvar</span><span class="p">}</span>
            <span class="o">$</span><span class="nv">f1</span> <span class="o">::</span> <span class="o">$</span><span class="nv">t1</span>
            <span class="o">$</span><span class="nv">f2</span> <span class="o">::</span> <span class="o">$</span><span class="nv">t2</span>
        <span class="k">end</span>
    <span class="k">end</span> <span class="o">=&gt;</span>
    <span class="k">quote</span>
        <span class="k">struct</span> <span class="o">$</span><span class="nv">name</span><span class="p">{</span><span class="o">$</span><span class="nv">tvar</span><span class="p">}</span>
            <span class="o">$</span><span class="nv">f1</span> <span class="o">::</span> <span class="o">$</span><span class="nv">t1</span>
            <span class="o">$</span><span class="nv">f2</span> <span class="o">::</span> <span class="o">$</span><span class="nv">t2</span>
        <span class="k">end</span>
    <span class="k">end</span> <span class="o">|&gt;</span> <span class="nv">rmlines</span> <span class="o">==</span> <span class="nv">expr</span>
<span class="k">end</span> <span class="c"># true</span>
</pre></div>
</div>
<p><strong>How you create an AST, then how you match them.</strong></p>
<p><strong>How you use AST interpolations(<code class="docutils literal notranslate"><span class="pre">$</span></code> operation), then how you use capturing patterns on them.</strong></p>
<p>The pattern <code class="docutils literal notranslate"><span class="pre">quote</span> <span class="pre">..</span> <span class="pre">end</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">:(begin</span> <span class="pre">...</span> <span class="pre">end)</span></code>.</p>
<p>Additionally, you can use any other patterns simultaneously when matching ASTs. In fact, there are regular patterns inside a <code class="docutils literal notranslate"><span class="pre">$</span></code> expression of your AST pattern.</p>
<p>A more complex example presented here might help with your comprehension about this:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nv">ast</span> <span class="o">=</span> <span class="k">quote</span>
    <span class="k">function</span> <span class="nf">f</span><span class="p">(</span><span class="nv">a</span><span class="p">,</span> <span class="nv">b</span><span class="p">,</span> <span class="nv">c</span><span class="p">,</span> <span class="nv">d</span><span class="p">)</span>
      <span class="k">let</span> <span class="nv">d</span> <span class="o">=</span> <span class="nv">a</span> <span class="o">+</span> <span class="nv">b</span> <span class="o">+</span> <span class="nv">c</span><span class="p">,</span> <span class="nv">e</span> <span class="o">=</span> <span class="nv">x</span> <span class="o">-&gt;</span> <span class="m">2</span><span class="nv">x</span> <span class="o">+</span> <span class="nv">d</span>
          <span class="nf">e</span><span class="p">(</span><span class="nv">d</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="nd">@match</span> <span class="nv">ast</span> <span class="k">begin</span>
    <span class="k">quote</span>
        <span class="o">$</span><span class="p">(</span><span class="o">::</span><span class="nb">LineNumberNode</span><span class="p">)</span>

        <span class="k">function</span> <span class="o">$</span><span class="nf">funcname</span><span class="p">(</span>
            <span class="o">$</span><span class="nv">firstarg</span><span class="p">,</span>
            <span class="o">$</span><span class="p">(</span><span class="nv">args</span><span class="p">...),</span>
            <span class="o">$</span><span class="p">(</span><span class="nv">a</span> <span class="o">&amp;&amp;</span> <span class="k">if</span> <span class="nf">islowercase</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nv">a</span><span class="p">)[</span><span class="m">1</span><span class="p">])</span> <span class="k">end</span><span class="p">))</span>

            <span class="o">$</span><span class="p">(</span><span class="o">::</span><span class="nb">LineNumberNode</span><span class="p">)</span>
            <span class="k">let</span> <span class="o">$</span><span class="nv">bind_name</span> <span class="o">=</span> <span class="nv">a</span> <span class="o">+</span> <span class="nv">b</span> <span class="o">+</span> <span class="o">$</span><span class="nv">last_operand</span><span class="p">,</span> <span class="o">$</span><span class="p">(</span><span class="nv">other_bindings</span><span class="p">...)</span>
                <span class="o">$</span><span class="p">(</span><span class="o">::</span><span class="nb">LineNumberNode</span><span class="p">)</span>
                <span class="o">$</span><span class="nf">app_fn</span><span class="p">(</span><span class="o">$</span><span class="nv">app_arg</span><span class="p">)</span>
                <span class="o">$</span><span class="p">(</span><span class="nv">block1</span><span class="p">...)</span>
            <span class="k">end</span>

            <span class="o">$</span><span class="p">(</span><span class="nv">block2</span><span class="p">...)</span>
        <span class="k">end</span>
    <span class="k">end</span> <span class="o">&amp;&amp;</span> <span class="k">if</span> <span class="nb">isempty</span><span class="p">(</span><span class="nv">block1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nb">isempty</span><span class="p">(</span><span class="nv">block2</span><span class="p">)</span> <span class="k">end</span> <span class="o">=&gt;</span>

         <span class="nb">Dict</span><span class="p">(</span><span class="o">:</span><span class="nv">funcname</span> <span class="o">=&gt;</span> <span class="nv">funcname</span><span class="p">,</span>
              <span class="o">:</span><span class="nv">firstarg</span> <span class="o">=&gt;</span> <span class="nv">firstarg</span><span class="p">,</span>
              <span class="o">:</span><span class="nv">args</span>     <span class="o">=&gt;</span> <span class="nv">args</span><span class="p">,</span>
              <span class="o">:</span><span class="nv">last_operand</span> <span class="o">=&gt;</span> <span class="nv">last_operand</span><span class="p">,</span>
              <span class="o">:</span><span class="nv">other_bindings</span> <span class="o">=&gt;</span> <span class="nv">other_bindings</span><span class="p">,</span>
              <span class="o">:</span><span class="nv">app_fn</span>         <span class="o">=&gt;</span> <span class="nv">app_fn</span><span class="p">,</span>
              <span class="o">:</span><span class="nv">app_arg</span>        <span class="o">=&gt;</span> <span class="nv">app_arg</span><span class="p">)</span>
<span class="k">end</span>

<span class="c"># Dict{Symbol,Any} with 7 entries:</span>
<span class="c">#   :app_fn         =&gt; :e</span>
<span class="c">#   :args           =&gt; Any[:b, :c]</span>
<span class="c">#   :firstarg       =&gt; :a</span>
<span class="c">#   :funcname       =&gt; :f</span>
<span class="c">#   :other_bindings =&gt; Any[:(e = (x-&gt;begin…</span>
<span class="c">#   :last_operand   =&gt; :c</span>
<span class="c">#   :app_arg        =&gt; :d</span>
</pre></div>
</div>
<p>If you are interested, here are several useful articles about AST Patterns:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.reddit.com/r/Julia/comments/ap4xwr/mlstylejl_a_modern_way_to_manipulate_asts/">A Modern Way to Manipulate ASTs</a>.</p></li>
<li><p><a class="reference external" href="https://discourse.julialang.org/t/an-elegant-and-efficient-way-to-extract-something-from-asts/19123">An Elegant and Efficient Way to Extract Something from ASTs</a>.</p></li>
</ul>
</section>
<section id="advanced-do-patterns-many-patterns">
<h2>Advanced: Do-Patterns &amp; Many-Patterns<a class="headerlink" href="#advanced-do-patterns-many-patterns" title="Permalink to this headline">¶</a></h2>
<p>To introduce side-effects into pattern matching, we provide a built-in pattern called the <code class="docutils literal notranslate"><span class="pre">Do</span></code> pattern.</p>
<p>Also, a pattern called <code class="docutils literal notranslate"><span class="pre">Many</span></code> can work with <code class="docutils literal notranslate"><span class="pre">Do</span></code> pattern in a perfect way.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@match</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">]</span> <span class="k">begin</span>
    <span class="nf">Many</span><span class="p">(</span><span class="o">::</span><span class="nb">Int</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">true</span>
    <span class="nv">_</span> <span class="o">=&gt;</span> <span class="k">false</span>
<span class="k">end</span> <span class="c"># true</span>

<span class="nd">@match</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span>  <span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="p">:</span><span class="nv">a</span><span class="p">,</span> <span class="p">:</span><span class="nv">b</span><span class="p">,</span> <span class="p">:</span><span class="nv">c</span><span class="p">]</span> <span class="k">begin</span>
    <span class="nf">Do</span><span class="p">(</span><span class="nv">count</span> <span class="o">=</span> <span class="m">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="nv">Many</span><span class="p">[</span>
        <span class="nv">a</span><span class="o">::</span><span class="nb">Int</span> <span class="o">&amp;&amp;</span> <span class="nf">Do</span><span class="p">(</span><span class="nv">count</span> <span class="o">=</span> <span class="nv">count</span> <span class="o">+</span> <span class="nv">a</span><span class="p">)</span> <span class="o">||</span>
        <span class="o">::</span><span class="nb">String</span>                        <span class="o">||</span>
        <span class="o">::</span><span class="nb">Symbol</span> <span class="o">&amp;&amp;</span> <span class="nf">Do</span><span class="p">(</span><span class="nv">count</span> <span class="o">=</span> <span class="nv">count</span> <span class="o">+</span> <span class="m">1</span><span class="p">)</span>
    <span class="p">]</span> <span class="o">=&gt;</span> <span class="nv">count</span>
<span class="k">end</span> <span class="c"># 9</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Do</span></code> and <code class="docutils literal notranslate"><span class="pre">Many</span></code> may be not used very often but quite convenient for some specific domain.</p>
<p><strong>P.S 1</strong>: when assigning variables with <code class="docutils literal notranslate"><span class="pre">Do</span></code>, don’t do <code class="docutils literal notranslate"><span class="pre">Do((x,</span> <span class="pre">y)</span> <span class="pre">=</span> <span class="pre">expr)</span></code>, use this: <code class="docutils literal notranslate"><span class="pre">Do(x</span> <span class="pre">=</span> <span class="pre">expr[1],</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">expr[2])</span></code>. Our pattern compile needs to aware the scope change!</p>
<p><strong>P.S 2</strong>: <code class="docutils literal notranslate"><span class="pre">Do[x...]</span></code> is an eye candy for <code class="docutils literal notranslate"><span class="pre">Do(x)</span></code>, and so does <code class="docutils literal notranslate"><span class="pre">Many[x]</span></code> for <code class="docutils literal notranslate"><span class="pre">Many(x)</span></code>. <strong>HOWEVER</strong>, do not use <code class="docutils literal notranslate"><span class="pre">begin</span> <span class="pre">end</span></code> syntax in <code class="docutils literal notranslate"><span class="pre">Do[...]</span></code> or <code class="docutils literal notranslate"><span class="pre">Many[...]</span></code>. Julia restricts the parser and it’ll not get treated as a <code class="docutils literal notranslate"><span class="pre">begin</span> <span class="pre">end</span></code> block.</p>
<p><strong>P.S 3</strong>: The <a class="reference external" href="#let-patterns"><code class="docutils literal notranslate"><span class="pre">let</span></code> pattern</a> is different from the <code class="docutils literal notranslate"><span class="pre">Do</span></code> pattern.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Do[x=y]</span></code> changes <code class="docutils literal notranslate"><span class="pre">x</span></code>, but <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span> <span class="pre">end</span></code> shadows <code class="docutils literal notranslate"><span class="pre">x</span></code>. <code class="docutils literal notranslate"><span class="pre">let</span></code> may also change a variable’s value. Check the documents of <code class="docutils literal notranslate"><span class="pre">&#64;switch</span></code> macro.</p></li>
<li><p>You can write non-binding in <code class="docutils literal notranslate"><span class="pre">Do</span></code>: <code class="docutils literal notranslate"><span class="pre">Do[println(1)]</span></code>, but you cannot do this in <code class="docutils literal notranslate"><span class="pre">let</span></code> patterns.</p></li>
</ul>
</section>
<section id="advanced-let-patterns">
<h2>Advanced: Let Patterns<a class="headerlink" href="#advanced-let-patterns" title="Permalink to this headline">¶</a></h2>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="m">1</span> <span class="k">begin</span>
           <span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="m">2</span> <span class="k">end</span> <span class="o">=&gt;</span> <span class="nv">x</span>
       <span class="k">end</span>
<span class="m">2</span>
</pre></div>
</div>
<p>Bind a variable without changing the value of existing variables, i.e., <code class="docutils literal notranslate"><span class="pre">let</span></code> patterns shadow symbols.</p>
<p><code class="docutils literal notranslate"><span class="pre">let</span></code> may also change a variable’s value. Check the documents of <code class="docutils literal notranslate"><span class="pre">&#64;switch</span></code> macro.</p>
</section>
</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../_sources/syntax/pattern.md.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2020, thautwarm.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>