<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patterns &#8212; MLStyle.jl Documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="canonical" href="https://thautwarm.github.io/MLStyle.jl/latest/syntax/pattern.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The Switch Statements" href="switch.html" />
    <link rel="prev" title="Algebraic Data Types" href="adt.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default ">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          MLStyle.jl</a>
        <span class="navbar-text navbar-version pull-left"><b>latest</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="https://github.com/thautwarm/MLStyle.jl">GitHub</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">MLStyle.jl <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../what.html">What is MLStyle.jl?</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../what.html#motivations">Motivations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../why.html">Why use MLStyle.jl?</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../why.html#straightforward">Straightforward</a></li>
<li class="toctree-l2"><a class="reference internal" href="../why.html#performance-gain">Performance Gain</a></li>
<li class="toctree-l2"><a class="reference internal" href="../why.html#extensibility">Extensibility</a></li>
<li class="toctree-l2"><a class="reference internal" href="../why.html#referential-transparency">Referential Transparency</a></li>
<li class="toctree-l2"><a class="reference internal" href="../why.html#intuition-of-ast-manipulations">Intuition of AST Manipulations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../how.html">Installation, Documentations and Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preview.html">Preview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../preview.html#rock-paper-scissors">Rock Paper Scissors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../preview.html#homoiconic-pattern-matching-for-julia-asts">Homoiconic pattern matching for Julia ASTs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../preview.html#generalized-algebraic-data-types">Generalized Algebraic Data Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../preview.html#active-patterns">Active Patterns</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../benchmark.html">Benchmark</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../benchmark.html#arrays">Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../benchmark.html#tuples">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../benchmark.html#data-types">Data Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../benchmark.html#extracting-struct-definitions">Extracting Struct Definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../benchmark.html#misc">Misc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../benchmark.html#an-example-from-match-jl-documentation">An Example from Match.jl Documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../contribute.html">Contributing to MLStyle</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="adt.html">Algebraic Data Types</a><ul>
<li class="toctree-l2"><a class="reference internal" href="adt.html#cheat-sheet">Cheat Sheet</a></li>
<li class="toctree-l2"><a class="reference internal" href="adt.html#examples">Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="adt.html#example-modeling-arithmetic-operations">Example: Modeling Arithmetic Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="adt.html#about-type-parameters">About Type Parameters</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Patterns</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#literal-patterns">Literal Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#capturing-patterns">Capturing Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#type-patterns">Type Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#guards">Guards</a></li>
<li class="toctree-l2"><a class="reference internal" href="#and-patterns">And-Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#destructuring-tuple-array-and-dict-patterns">Destructuring Tuple Array and Dict Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#deconstruction-of-custom-composite-data">Deconstruction of Custom Composite Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#predicates">Predicates</a></li>
<li class="toctree-l2"><a class="reference internal" href="#range-patterns">Range Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reference-patterns">Reference Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#custom-patterns">Custom Patterns</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#support-pattern-matching-for-julia-enums">Support Pattern Matching for Julia Enums</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pattern-synonyms">Pattern Synonyms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#or-patterns">Or Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#advanced-type-patterns">Advanced Type Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#do-patterns-many-patterns">Do-Patterns &amp; Many-Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#let-patterns">Let Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#active-patterns">Active Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#expr-patterns">Expr Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#julia-code-as-expr-patterns">Julia Code as Expr Patterns</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="switch.html">The Switch Statements</a></li>
<li class="toctree-l1"><a class="reference internal" href="records.html">Records</a></li>
<li class="toctree-l1"><a class="reference internal" href="when.html">When Destructuring</a><ul>
<li class="toctree-l2"><a class="reference internal" href="when.html#allow-destructuring-in-let-binding">Allow Destructuring in Let-Binding</a></li>
<li class="toctree-l2"><a class="reference internal" href="when.html#sole-destructuring">Sole Destructuring</a></li>
<li class="toctree-l2"><a class="reference internal" href="when.html#multiple-branches">Multiple Branches</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pattern-function.html">Pattern Functions</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules/ast.html">MLStyle.Modules.AST</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../modules/ast.html#matchast">&#64;matchast</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/ast.html#capture"><code class="docutils literal notranslate"><span class="pre">Capture</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/ast.html#id1">&#64;capture</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../modules/cond.html">MLStyle.Modules.Cond</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../modules/cond.html#cond">&#64;cond</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/capture.html">Static Capturing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/capture.html#capture-pattern-from-mlstyle-modules-ast"><code class="docutils literal notranslate"><span class="pre">Capture</span></code> Pattern from <code class="docutils literal notranslate"><span class="pre">MLStyle.Modules.AST</span></code>:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/capture.html#raii-style">RAII-Style</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Structure <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Patterns</a><ul>
<li><a class="reference internal" href="#literal-patterns">Literal Patterns</a></li>
<li><a class="reference internal" href="#capturing-patterns">Capturing Patterns</a></li>
<li><a class="reference internal" href="#type-patterns">Type Patterns</a></li>
<li><a class="reference internal" href="#guards">Guards</a></li>
<li><a class="reference internal" href="#and-patterns">And-Patterns</a></li>
<li><a class="reference internal" href="#destructuring-tuple-array-and-dict-patterns">Destructuring Tuple Array and Dict Patterns</a></li>
<li><a class="reference internal" href="#deconstruction-of-custom-composite-data">Deconstruction of Custom Composite Data</a></li>
<li><a class="reference internal" href="#predicates">Predicates</a></li>
<li><a class="reference internal" href="#range-patterns">Range Patterns</a></li>
<li><a class="reference internal" href="#reference-patterns">Reference Patterns</a></li>
<li><a class="reference internal" href="#custom-patterns">Custom Patterns</a><ul>
<li><a class="reference internal" href="#support-pattern-matching-for-julia-enums">Support Pattern Matching for Julia Enums</a></li>
<li><a class="reference internal" href="#pattern-synonyms">Pattern Synonyms</a></li>
</ul>
</li>
<li><a class="reference internal" href="#or-patterns">Or Patterns</a></li>
<li><a class="reference internal" href="#advanced-type-patterns">Advanced Type Patterns</a></li>
<li><a class="reference internal" href="#do-patterns-many-patterns">Do-Patterns &amp; Many-Patterns</a></li>
<li><a class="reference internal" href="#let-patterns">Let Patterns</a></li>
<li><a class="reference internal" href="#active-patterns">Active Patterns</a></li>
<li><a class="reference internal" href="#expr-patterns">Expr Patterns</a></li>
<li><a class="reference internal" href="#julia-code-as-expr-patterns">Julia Code as Expr Patterns</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="adt.html" title="Previous Chapter: Algebraic Data Types"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; Algebraic Data Types</span>
    </a>
  </li>
  <li>
    <a href="switch.html" title="Next Chapter: The Switch Statements"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">The Switch Statements &raquo;</span>
    </a>
  </li>
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <div class="section" id="patterns">
<h1>Patterns<a class="headerlink" href="#patterns" title="Permalink to this headline">¶</a></h1>
<p>Patterns provide convenient ways to manipulate data. The basic syntax for pattern matching with MLStyle is of the form</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@match</span> <span class="nv">data</span> <span class="k">begin</span>
    <span class="nv">pattern1</span> <span class="o">=&gt;</span> <span class="nv">result1</span>
    <span class="nv">pattern2</span> <span class="o">=&gt;</span> <span class="nv">result2</span>
    <span class="p">...</span>
    <span class="nv">patternn</span> <span class="o">=&gt;</span> <span class="nv">resultn</span>
<span class="k">end</span>
</pre></div>
</div>
<p>MLStyle will first test if <code class="docutils literal notranslate"><span class="pre">data</span></code> is matched by <code class="docutils literal notranslate"><span class="pre">pattern1</span></code> and if it does match, return <code class="docutils literal notranslate"><span class="pre">result1</span></code>. If <code class="docutils literal notranslate"><span class="pre">pattern1</span></code> does not match, then MLStyle moves on to the next pattern. If no pattern in the list matches <code class="docutils literal notranslate"><span class="pre">data</span></code>, an error is thrown.</p>
<p>In version 0.4.1 and newer, if you only have a single pattern you may instead write</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@match</span> <span class="nv">data</span> <span class="nv">pattern</span> <span class="o">=&gt;</span> <span class="nv">result</span>
</pre></div>
</div>
<p>without the block syntax.</p>
<div class="section" id="literal-patterns">
<h2>Literal Patterns<a class="headerlink" href="#literal-patterns" title="Permalink to this headline">¶</a></h2>
<p>Patterns with a literal (e.g. <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">false</span></code>, <code class="docutils literal notranslate"><span class="pre">nothing</span></code>, <code class="docutils literal notranslate"><span class="pre">4.0</span></code>, <code class="docutils literal notranslate"><span class="pre">1f-6</span></code>, etc) on the left hand side will check if the the argument is equal to that literal:</p>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="m">10</span> <span class="k">begin</span>
           <span class="m">1</span>  <span class="o">=&gt;</span> <span class="s">&quot;wrong!&quot;</span>
           <span class="m">2</span>  <span class="o">=&gt;</span> <span class="s">&quot;wrong!&quot;</span>
           <span class="m">10</span> <span class="o">=&gt;</span> <span class="s">&quot;right!&quot;</span>
       <span class="k">end</span>
<span class="s">&quot;right!&quot;</span>
</pre></div>
</div>
<p>All literal data introduced with Julia syntax could be matched by literal patterns.</p>
<p>However, note that the equality is strict for primitive types(<code class="docutils literal notranslate"><span class="pre">Int8-64</span></code>, <code class="docutils literal notranslate"><span class="pre">UInt8-64</span></code>, <code class="docutils literal notranslate"><span class="pre">Bool</span></code>, etc.) and singleton types(<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Data</span> <span class="pre">end;</span> <span class="pre">Data()</span></code>).</p>
<p>Specifically, <strong>substrings can match a literal string.</strong></p>
</div>
<div class="section" id="capturing-patterns">
<h2>Capturing Patterns<a class="headerlink" href="#capturing-patterns" title="Permalink to this headline">¶</a></h2>
<p>A pattern where there is a symbol such as <code class="docutils literal notranslate"><span class="pre">x</span></code> on the left hand side will bind the input value to that symbol and let you use that captured value on the right hand side</p>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="m">1</span> <span class="k">begin</span>
           <span class="nv">x</span> <span class="o">=&gt;</span> <span class="nv">x</span> <span class="o">+</span> <span class="m">1</span>
       <span class="k">end</span>
<span class="m">2</span>
</pre></div>
</div>
<p>You can put <code class="docutils literal notranslate"><span class="pre">_</span></code> on the left hand side of a pattern if you don’t care about what the captured value is.</p>
<p>However, sometimes a symbol might not be used for capturing. If and only if some visible global variable <code class="docutils literal notranslate"><span class="pre">x</span></code> satisfying <code class="docutils literal notranslate"><span class="pre">MLStyle.is_enum(x)</span> <span class="pre">==</span> <span class="pre">true</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> is used as an enum pattern.</p>
<p>Check <a class="reference external" href="#custom-patterns">Custom Patterns</a> for details.</p>
</div>
<div class="section" id="type-patterns">
<h2>Type Patterns<a class="headerlink" href="#type-patterns" title="Permalink to this headline">¶</a></h2>
<p>Writing <code class="docutils literal notranslate"><span class="pre">::Foo</span></code> on the left hand side of a pattern will match if the input is of type <code class="docutils literal notranslate"><span class="pre">Foo</span></code>. You can conbine this with a literal pattern by writing <code class="docutils literal notranslate"><span class="pre">x::Foo</span></code> which will match inputs of type <code class="docutils literal notranslate"><span class="pre">Foo</span></code> and bind them to a variable <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="m">1</span> <span class="k">begin</span>
           <span class="o">::</span><span class="nb">Float64</span>  <span class="o">=&gt;</span> <span class="k">nothing</span>
           <span class="nv">b</span> <span class="o">::</span> <span class="nb">Int</span> <span class="o">=&gt;</span> <span class="nv">b</span>
           <span class="nv">_</span>        <span class="o">=&gt;</span> <span class="k">nothing</span>
       <span class="k">end</span>
<span class="m">1</span>
</pre></div>
</div>
</div>
<div class="section" id="guards">
<h2>Guards<a class="headerlink" href="#guards" title="Permalink to this headline">¶</a></h2>
<p>Writing <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">cond</span> <span class="pre">end</span></code> as a pattern will match if <code class="docutils literal notranslate"><span class="pre">cond==true</span></code></p>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="m">1</span><span class="p">.</span><span class="m">0</span> <span class="k">begin</span>
           <span class="k">if</span> <span class="m">1</span> <span class="o">&lt;</span> <span class="m">5</span> <span class="k">end</span>  <span class="o">=&gt;</span> <span class="nv">√</span><span class="p">(</span><span class="m">5</span> <span class="o">-</span> <span class="m">1</span><span class="p">)</span>
       <span class="k">end</span>
<span class="m">2</span><span class="p">.</span><span class="m">0</span>
</pre></div>
</div>
<p>Unlike most of ML languages or other libraries who only permit guards in the end of a case clause,
MLStyle allows you to put guards anywhere during matching.</p>
<p>However, remember, due to some Julia optimization details, even if the guards can be put
in the middle of a matching process, still you’d better postpone it to the end of matching, for better performance.</p>
<p>Sometimes, in practice, you might want to introduce type variables into the scope, in this case use <code class="docutils literal notranslate"><span class="pre">where</span></code> clause, and see <a class="reference external" href="#advanced-type-patterns">Advanced Type Patterns</a> for more details.</p>
</div>
<div class="section" id="and-patterns">
<h2>And-Patterns<a class="headerlink" href="#and-patterns" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">pat2</span> <span class="pre">&amp;&amp;</span> <span class="pre">pat2</span></code> on the left hand side of a pattern will match if and only if <code class="docutils literal notranslate"><span class="pre">pat1</span></code> and <code class="docutils literal notranslate"><span class="pre">pat2</span></code> match individually. This lets you combine two separate patterns together,</p>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="m">2</span> <span class="k">begin</span>
           <span class="nv">x</span><span class="o">::</span><span class="nb">Int</span> <span class="o">&amp;&amp;</span> <span class="k">if</span> <span class="nv">x</span> <span class="o">&lt;</span> <span class="m">5</span> <span class="k">end</span> <span class="o">=&gt;</span> <span class="nv">√</span><span class="p">(</span><span class="m">5</span> <span class="o">-</span> <span class="nv">x</span><span class="p">)</span>
       <span class="k">end</span>
<span class="m">1</span><span class="p">.</span><span class="m">7320508075688772</span>
</pre></div>
</div>
<ul class="simple">
<li><p>As Pattern</p></li>
</ul>
<p>Writing <code class="docutils literal notranslate"><span class="pre">pat</span> <span class="pre">&amp;&amp;</span> <span class="pre">x</span></code> on the left hand side of a pattern will bind the input to <code class="docutils literal notranslate"><span class="pre">x</span></code> if <code class="docutils literal notranslate"><span class="pre">pat</span></code> matches the input, allowing the input to be used on the right hand side. This is sometimes called an As-Pattern in ML derived languages, but in MLStyle, it is just a subset of the functionality in the And-Pattern</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span> <span class="k">begin</span>
           <span class="p">(</span><span class="nv">a</span><span class="p">,</span> <span class="nv">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nv">c</span> <span class="o">=&gt;</span> <span class="nv">c</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="o">==</span> <span class="nv">a</span> <span class="o">&amp;&amp;</span> <span class="nv">c</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="o">==</span> <span class="nv">b</span>
       <span class="k">end</span>
<span class="k">true</span>
</pre></div>
</div>
</div>
<div class="section" id="destructuring-tuple-array-and-dict-patterns">
<h2>Destructuring Tuple Array and Dict Patterns<a class="headerlink" href="#destructuring-tuple-array-and-dict-patterns" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Tuple Patterns</p></li>
</ul>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="p">(</span><span class="m">5</span><span class="p">,</span> <span class="p">)))</span> <span class="k">begin</span>
           <span class="p">(</span><span class="nv">a</span><span class="p">,</span> <span class="nv">b</span><span class="p">,</span> <span class="p">(</span><span class="nv">c</span><span class="p">,</span> <span class="nv">d</span><span class="p">,</span> <span class="p">(</span><span class="m">5</span><span class="p">,</span> <span class="p">)))</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nv">a</span><span class="p">,</span> <span class="nv">b</span><span class="p">,</span> <span class="nv">c</span><span class="p">,</span> <span class="nv">d</span><span class="p">)</span>
       <span class="k">end</span>
<span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Array Patterns</p></li>
</ul>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nv">it</span> <span class="o">=</span> <span class="nd">@match</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">]</span> <span class="k">begin</span>
         <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="nv">pack</span><span class="p">...,</span> <span class="nv">a</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nv">pack</span><span class="p">,</span> <span class="nv">a</span><span class="p">)</span>
       <span class="k">end</span>
<span class="p">([</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">],</span> <span class="m">4</span><span class="p">)</span>

<span class="gp">julia&gt;</span> <span class="nb">first</span><span class="p">(</span><span class="nv">it</span><span class="p">)</span>
<span class="m">2</span><span class="o">-</span><span class="nv">element</span> <span class="nb">view</span><span class="p">(</span><span class="o">::</span><span class="nb">Array</span><span class="p">{</span><span class="nb">Int64</span><span class="p">,</span><span class="m">1</span><span class="p">},</span> <span class="m">2</span><span class="o">:</span><span class="m">3</span><span class="p">)</span> <span class="nv">with</span> <span class="nv">eltype</span> <span class="nb">Int64</span><span class="o">:</span>
 <span class="m">2</span>
 <span class="m">3</span>
<span class="gp">julia&gt;</span> <span class="nv">it</span><span class="p">[</span><span class="m">2</span><span class="p">]</span>
<span class="m">4</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Dict pattern(like <code class="docutils literal notranslate"><span class="pre">Elixir</span></code>’s dictionary matching or ML record matching)</p></li>
</ul>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nv">dict</span> <span class="o">=</span> <span class="nb">Dict</span><span class="p">(</span><span class="m">1</span> <span class="o">=&gt;</span> <span class="m">2</span><span class="p">,</span> <span class="s">&quot;3&quot;</span> <span class="o">=&gt;</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span> <span class="o">=&gt;</span> <span class="nb">Dict</span><span class="p">(</span><span class="m">6</span> <span class="o">=&gt;</span> <span class="m">7</span><span class="p">))</span>
<span class="nb">Dict</span><span class="p">{</span><span class="nb">Any</span><span class="p">,</span><span class="nb">Any</span><span class="p">}</span> <span class="nv">with</span> <span class="m">3</span> <span class="nv">entries</span><span class="o">:</span>
  <span class="m">1</span>   <span class="o">=&gt;</span> <span class="m">2</span>
  <span class="m">5</span>   <span class="o">=&gt;</span> <span class="nb">Dict</span><span class="p">(</span><span class="m">6</span><span class="o">=&gt;</span><span class="m">7</span><span class="p">)</span>
  <span class="s">&quot;3&quot;</span> <span class="o">=&gt;</span> <span class="m">4</span>

<span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="nv">dict</span> <span class="k">begin</span>
           <span class="nb">Dict</span><span class="p">(</span><span class="s">&quot;3&quot;</span> <span class="o">=&gt;</span> <span class="nv">four</span><span class="o">::</span><span class="nb">Int</span><span class="p">,</span>
                 <span class="m">5</span>  <span class="o">=&gt;</span> <span class="nb">Dict</span><span class="p">(</span><span class="m">6</span> <span class="o">=&gt;</span> <span class="nv">sev</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="k">if</span> <span class="nv">four</span> <span class="o">&lt;</span> <span class="nv">sev</span> <span class="k">end</span> <span class="o">=&gt;</span> <span class="nv">sev</span>
       <span class="k">end</span>
<span class="m">7</span>
</pre></div>
</div>
<p>Note that, due to the lack of an operation for distinguishing <code class="docutils literal notranslate"><span class="pre">nothing</span></code> from “key not found” in Julia’s standard library, the dictionary pattern has a little overhead. Things will get solved after <a class="reference external" href="https://github.com/JuliaLang/julia/pull/34821">Julia#34821</a> gets done.</p>
<p><strong>P.S</strong>:  MLStyle will not refer an external package to solve this issue, as MLStyle is generating “runtime support free” code, which means that any code generated by MLStyle itself depends only on Stdlib. This feature allows MLStyle to be introduced as a dependency only in development, instead of being distributed together to downstream codes.</p>
</div>
<div class="section" id="deconstruction-of-custom-composite-data">
<h2>Deconstruction of Custom Composite Data<a class="headerlink" href="#deconstruction-of-custom-composite-data" title="Permalink to this headline">¶</a></h2>
<p>In order to deconstruct arbitrary data types in a similar way to <code class="docutils literal notranslate"><span class="pre">Tuple</span></code>, <code class="docutils literal notranslate"><span class="pre">Array</span></code> and <code class="docutils literal notranslate"><span class="pre">Dict</span></code>, simply declare them to be record types with the <code class="docutils literal notranslate"><span class="pre">&#64;as_record</span></code> macro.</p>
<p>Here is an example, check more about ADTs(and GADTs) at <a class="reference external" href="https://thautwarm.github.io/MLStyle.jl/latest/syntax/adt">Algebraic Data Type Syntax in MLStyle</a>.</p>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@data</span> <span class="nv">Color</span> <span class="k">begin</span>
         <span class="nf">RGB</span><span class="p">(</span><span class="nv">r</span><span class="o">::</span><span class="nb">Int</span><span class="p">,</span> <span class="nv">g</span><span class="o">::</span><span class="nb">Int</span><span class="p">,</span> <span class="nv">b</span><span class="o">::</span><span class="nb">Int</span><span class="p">)</span>
         <span class="nf">Gray</span><span class="p">(</span><span class="nb">Int</span><span class="p">)</span>
       <span class="k">end</span>

<span class="gp">julia&gt;</span> <span class="c"># treating those types as records for more flexible pattern matching</span>

<span class="gp">julia&gt;</span> <span class="nd">@as_record</span> <span class="nv">RGB</span>

<span class="gp">julia&gt;</span> <span class="nd">@as_record</span> <span class="nv">Gray</span>

<span class="gp">julia&gt;</span> <span class="nf">color_to_int</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="o">=</span> <span class="nd">@match</span> <span class="nv">x</span> <span class="k">begin</span>
           <span class="nf">RGB</span><span class="p">(;</span><span class="nv">r</span><span class="p">,</span> <span class="nv">g</span><span class="p">,</span> <span class="nv">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="m">16</span> <span class="o">+</span> <span class="nv">b</span> <span class="o">+</span> <span class="m">6</span><span class="nv">g</span> <span class="o">+</span> <span class="m">36</span><span class="nv">r</span>
           <span class="nf">Gray</span><span class="p">(</span><span class="nv">i</span><span class="p">)</span>       <span class="o">=&gt;</span> <span class="m">232</span> <span class="o">+</span> <span class="nv">i</span>
       <span class="k">end</span>
<span class="nv">color_to_int</span> <span class="p">(</span><span class="nv">generic</span> <span class="k">function</span> <span class="nv">with</span> <span class="m">1</span> <span class="nv">method</span><span class="p">)</span>

<span class="gp">julia&gt;</span> <span class="nf">RGB</span><span class="p">(</span><span class="m">200</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">200</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="nv">color_to_int</span>
<span class="m">7416</span>

<span class="gp">julia&gt;</span> <span class="nf">Gray</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>         <span class="o">|&gt;</span> <span class="nv">color_to_int</span>
<span class="m">242</span>
</pre></div>
</div>
<p>In above cases, after <code class="docutils literal notranslate"><span class="pre">&#64;as_record</span> <span class="pre">T</span></code>, we can use something called <a class="reference external" href="https://dev.realworldocaml.org/records.html#field-punning">field punning</a> to match structures very conveniently.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@match</span> <span class="nv">rbg_datum</span> <span class="k">begin</span>
    <span class="nf">RGB</span><span class="p">(;</span><span class="nv">r</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="k">if</span> <span class="nv">r</span> <span class="o">&lt;</span> <span class="m">20</span> <span class="k">end</span> <span class="o">=&gt;</span> <span class="p">...</span>
    <span class="nf">RGB</span><span class="p">(;</span><span class="nv">r</span><span class="p">,</span> <span class="nv">g</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="k">if</span> <span class="m">10</span><span class="nv">r</span> <span class="o">&lt;</span> <span class="nv">g</span> <span class="k">end</span> <span class="o">=&gt;</span> <span class="p">...</span>
    <span class="p">...</span>
<span class="k">end</span>
</pre></div>
</div>
<p>As you can see, field punning can be partial.</p>
</div>
<div class="section" id="predicates">
<h2>Predicates<a class="headerlink" href="#predicates" title="Permalink to this headline">¶</a></h2>
<p>Equivalent to guard patterns, writing <code class="docutils literal notranslate"><span class="pre">GuardBy(f)</span></code> in a pattern will match if and only if <code class="docutils literal notranslate"><span class="pre">f</span></code> applied to the pattern matching input gives true:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span> <span class="nf">pred</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span>
    <span class="nv">x</span> <span class="o">&gt;</span> <span class="m">5</span>
<span class="k">end</span>

<span class="nd">@match</span> <span class="nv">x</span> <span class="k">begin</span>
    <span class="nv">x</span> <span class="o">&amp;&amp;</span> <span class="nf">GuardBy</span><span class="p">(</span><span class="nv">pred</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="m">5</span> <span class="o">-</span> <span class="nv">x</span> <span class="c"># only succeed when x &gt; 5</span>
    <span class="nv">_</span>        <span class="o">=&gt;</span> <span class="m">1</span>
<span class="k">end</span>

<span class="nd">@match</span> <span class="nv">x</span> <span class="k">begin</span>
    <span class="nv">x</span> <span class="o">&amp;&amp;</span> <span class="nf">GuardBy</span><span class="p">(</span><span class="nv">x</span> <span class="o">-&gt;</span> <span class="nv">x</span> <span class="o">&gt;</span> <span class="m">5</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="m">5</span> <span class="o">-</span> <span class="nv">x</span> <span class="c"># only succeed when x &gt; 5</span>
    <span class="nv">_</span>        <span class="o">=&gt;</span> <span class="m">1</span>
<span class="k">end</span>
</pre></div>
</div>
</div>
<div class="section" id="range-patterns">
<h2>Range Patterns<a class="headerlink" href="#range-patterns" title="Permalink to this headline">¶</a></h2>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="m">1</span> <span class="k">begin</span>
           <span class="m">0</span><span class="o">:</span><span class="m">2</span><span class="o">:</span><span class="m">10</span> <span class="o">=&gt;</span> <span class="m">1</span>
           <span class="m">1</span><span class="o">:</span><span class="m">10</span> <span class="o">=&gt;</span> <span class="m">2</span>
       <span class="k">end</span>
<span class="m">2</span>
</pre></div>
</div>
</div>
<div class="section" id="reference-patterns">
<h2>Reference Patterns<a class="headerlink" href="#reference-patterns" title="Permalink to this headline">¶</a></h2>
<p>This feature is from <code class="docutils literal notranslate"><span class="pre">Elixir</span></code> which could slightly extends ML based pattern matching.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nv">c</span> <span class="o">=</span> <span class="p">...</span>
<span class="nd">@match</span> <span class="p">(</span><span class="nv">x</span><span class="p">,</span> <span class="nv">y</span><span class="p">)</span> <span class="k">begin</span>
    <span class="p">(</span><span class="o">&amp;</span><span class="nv">c</span><span class="p">,</span> <span class="nv">_</span><span class="p">)</span>  <span class="o">=&gt;</span> <span class="s">&quot;x equals to c!&quot;</span>
    <span class="p">(</span><span class="nv">_</span><span class="p">,</span>  <span class="o">&amp;</span><span class="nv">c</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s">&quot;y equals to c!&quot;</span>
    <span class="nv">_</span>        <span class="o">=&gt;</span> <span class="s">&quot;none of x and y equal to c&quot;</span>
<span class="k">end</span>
</pre></div>
</div>
</div>
<div class="section" id="custom-patterns">
<h2>Custom Patterns<a class="headerlink" href="#custom-patterns" title="Permalink to this headline">¶</a></h2>
<p>As we’ve suggested in <a class="reference external" href="#capturing-patterns">Capturing-Patterns</a>,
you can always define your own patterns with MLStyle and easily leverge our compiler and optimizer.</p>
<p>You can extend following APIs for your pattern objects, to implement custom patterns:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">MLStyle.pattern_uncall</span></code></p>
<ul>
<li><p>args:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">pat_obj</span></code></p>
<p>your pattern object, should be a global variable in some module. The pattern is visible if and only if the global variable is visible in current scope.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">expr_to_pat::Function</span></code></p>
<p>this is provided for you to transform an AST into patterns, for instance, <code class="docutils literal notranslate"><span class="pre">expr_to_pat(:([a,</span> <span class="pre">1]))</span></code>, with which you create a pattern same as <code class="docutils literal notranslate"><span class="pre">[a,</span> <span class="pre">1]</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">type_params</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type_args</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">args</span></code></p></li>
</ul>
</li>
<li><p>usage</p>
<p>We compile the AST <code class="docutils literal notranslate"><span class="pre">pat_obj{c,</span> <span class="pre">d}(e,</span> <span class="pre">f)</span> <span class="pre">where</span> <span class="pre">{a,</span> <span class="pre">b}</span></code> into
patterns with <code class="docutils literal notranslate"><span class="pre">MLStyle.pattern_uncall(pat_obj,</span> <span class="pre">expr_to_pat,</span> <span class="pre">[:a,</span> <span class="pre">:b],</span> <span class="pre">[:c,</span> <span class="pre">:d],</span> <span class="pre">[:e,</span> <span class="pre">:f])</span></code></p>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">MLStyle.pattern_unref</span></code></p>
<ul>
<li><p>args:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pat_obj</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">expr_to_pat</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">args</span></code></p></li>
</ul>
</li>
<li><p>usage</p>
<p>We compile the AST <code class="docutils literal notranslate"><span class="pre">pat_obj[a,</span> <span class="pre">b]</span></code> into patterns with
<code class="docutils literal notranslate"><span class="pre">MLStyle.pattern_unref(pat_obj,</span> <span class="pre">expr_to_pat,</span> <span class="pre">[:a,</span> <span class="pre">:b]</span></code>.</p>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">MLStyle.is_enum</span></code></p>
<p>In a pattern <code class="docutils literal notranslate"><span class="pre">[A,</span> <span class="pre">B]</span></code>, usually we think both <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are capturing patterns. However, it is handy if we can have a pattern <code class="docutils literal notranslate"><span class="pre">A</span></code> whose match means comparing to the global variable <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>To achieve this, we provide <code class="docutils literal notranslate"><span class="pre">MLStyle.is_enum</span></code>.
For a visible global variable <code class="docutils literal notranslate"><span class="pre">A</span></code>, if <code class="docutils literal notranslate"><span class="pre">MLStyle.is_enum(A)</span> <span class="pre">==</span> <span class="pre">true</span></code>, a symbol <code class="docutils literal notranslate"><span class="pre">A</span></code> will compiled into patterns with <code class="docutils literal notranslate"><span class="pre">MLStyle.pattern_uncall(A,</span> <span class="pre">expr_to_ast,</span> <span class="pre">[],</span> <span class="pre">[],</span> <span class="pre">[])</span></code></p>
</li>
</ul>
<p>We present some examples for understandability:</p>
<div class="section" id="support-pattern-matching-for-julia-enums">
<h3>Support Pattern Matching for Julia Enums<a class="headerlink" href="#support-pattern-matching-for-julia-enums" title="Permalink to this headline">¶</a></h3>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="k">using</span> <span class="nv">MLStyle</span><span class="p">.</span><span class="nv">ActivePatterns</span><span class="o">:</span> <span class="nv">literal</span>
<span class="gp">julia&gt;</span> <span class="nd">@enum</span> <span class="nv">E</span> <span class="nv">E1</span> <span class="nv">E2</span>
<span class="c"># mark E1, E2 as non-capturing patterns</span>
<span class="gp">julia&gt;</span> <span class="nv">MLStyle</span><span class="p">.</span><span class="nf">is_enum</span><span class="p">(</span><span class="o">::</span><span class="nv">E</span><span class="p">)</span> <span class="o">=</span> <span class="k">true</span>
<span class="c"># tell the compiler how to match E1, E2</span>
<span class="gp">julia&gt;</span> <span class="nv">MLStyle</span><span class="p">.</span><span class="nf">pattern_uncall</span><span class="p">(</span><span class="nv">e</span><span class="o">::</span><span class="nv">E</span><span class="p">,</span> <span class="nv">_</span><span class="p">,</span> <span class="nv">_</span><span class="p">,</span> <span class="nv">_</span><span class="p">,</span> <span class="nv">_</span><span class="p">)</span> <span class="o">=</span> <span class="nf">literal</span><span class="p">(</span><span class="nv">e</span><span class="p">)</span>
<span class="gp">julia&gt;</span> <span class="nv">x</span> <span class="o">=</span> <span class="nv">E2</span>
<span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="nv">x</span> <span class="k">begin</span>
           <span class="nv">E1</span> <span class="o">=&gt;</span> <span class="s">&quot;match E1!&quot;</span>
           <span class="nv">E2</span> <span class="o">=&gt;</span> <span class="s">&quot;match E2!&quot;</span>
       <span class="k">end</span>
<span class="s">&quot;match E2!&quot;</span>
<span class="gp">julia&gt;</span> <span class="nd">@macroexpand</span> <span class="nd">@match</span> <span class="nv">x</span> <span class="k">begin</span>
                  <span class="nv">E1</span> <span class="o">=&gt;</span> <span class="s">&quot;match E1!&quot;</span>
                  <span class="nv">E2</span> <span class="o">=&gt;</span> <span class="s">&quot;match E2!&quot;</span>
        <span class="k">end</span>
</pre></div>
</div>
</div>
<div class="section" id="pattern-synonyms">
<h3>Pattern Synonyms<a class="headerlink" href="#pattern-synonyms" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/pattern_synonyms.html">pattern synonyms</a> is a tasty feature in Haskell programming language for defining patterns based on existing patterns.</p>
<p>We can support it:</p>
<p>suppose we want to regard <code class="docutils literal notranslate"><span class="pre">Triple</span></code> as a pattern <code class="docutils literal notranslate"><span class="pre">(_,</span> <span class="pre">_,</span> <span class="pre">_)</span></code></p>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="k">struct</span> <span class="nv">Triple</span> <span class="k">end</span>
<span class="gp">julia&gt;</span> <span class="nv">MLStyle</span><span class="p">.</span><span class="nf">pattern_uncall</span><span class="p">(</span><span class="o">::</span><span class="nb">Type</span><span class="p">{</span><span class="nv">Triple</span><span class="p">},</span> <span class="nv">expr_to_ast</span><span class="p">,</span> <span class="nv">_</span><span class="p">,</span> <span class="nv">_</span><span class="p">,</span> <span class="nv">_</span><span class="p">)</span> <span class="o">=</span>
            <span class="nf">expr_to_ast</span><span class="p">(</span><span class="o">:</span><span class="p">(</span>  <span class="p">(</span><span class="nv">_</span><span class="p">,</span> <span class="nv">_</span><span class="p">,</span> <span class="nv">_</span><span class="p">)</span>  <span class="p">))</span>
<span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span> <span class="k">begin</span>
            <span class="nv">Triple</span> <span class="o">=&gt;</span> <span class="s">&quot;triple&quot;</span>
            <span class="nv">_</span> <span class="o">=&gt;</span> <span class="s">&quot;no a triple&quot;</span>
        <span class="k">end</span>

<span class="s">&quot;no a triple&quot;</span>

<span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span> <span class="k">begin</span>
            <span class="nv">Triple</span> <span class="o">=&gt;</span> <span class="s">&quot;triple&quot;</span>
            <span class="nv">_</span> <span class="o">=&gt;</span> <span class="s">&quot;no a triple&quot;</span>
        <span class="k">end</span>

<span class="s">&quot;triple&quot;</span>
</pre></div>
</div>
<p><a class="reference external" href="#active-patterns">Active Patterns</a> and <a class="reference external" href="https://thautwarm.github.io/MLStyle.jl/latest/syntax/adt.html#cheat-sheet">ADTs</a> are implemented via custom patterns.</p>
<p>The custom patterns gives us so-called <strong>extensible pattern matching</strong>.</p>
</div>
</div>
<div class="section" id="or-patterns">
<h2>Or Patterns<a class="headerlink" href="#or-patterns" title="Permalink to this headline">¶</a></h2>
<p>Writing <code class="docutils literal notranslate"><span class="pre">pat1</span> <span class="pre">||</span> <span class="pre">pat2</span></code> will match if either <code class="docutils literal notranslate"><span class="pre">pat1</span></code> <em>or</em> <code class="docutils literal notranslate"><span class="pre">pat2</span></code> match. If <code class="docutils literal notranslate"><span class="pre">pat1</span></code> matches, MLStyle will not attempt to match <code class="docutils literal notranslate"><span class="pre">pat2</span></code>.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nf">test</span><span class="p">(</span><span class="nv">num</span><span class="p">)</span> <span class="o">=</span>
    <span class="nd">@match</span> <span class="nv">num</span> <span class="k">begin</span>
       <span class="o">::</span><span class="nb">Float64</span> <span class="o">||</span>
        <span class="m">0</span>        <span class="o">||</span>
        <span class="m">1</span>        <span class="o">||</span>
        <span class="m">2</span>        <span class="o">=&gt;</span> <span class="k">true</span>

        <span class="nv">_</span>        <span class="o">=&gt;</span> <span class="k">false</span>
    <span class="k">end</span>

<span class="nf">test</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>   <span class="c"># true</span>
<span class="nf">test</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>   <span class="c"># true</span>
<span class="nf">test</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>   <span class="c"># true</span>
<span class="nf">test</span><span class="p">(</span><span class="m">1</span><span class="p">.</span><span class="m">0</span><span class="p">)</span> <span class="c"># true</span>
<span class="nf">test</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>   <span class="c"># false</span>
<span class="nf">test</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span>  <span class="c"># false</span>
</pre></div>
</div>
<p>Tips: <code class="docutils literal notranslate"><span class="pre">Or</span> <span class="pre">Pattern</span></code>s could be nested.</p>
</div>
<div class="section" id="advanced-type-patterns">
<h2>Advanced Type Patterns<a class="headerlink" href="#advanced-type-patterns" title="Permalink to this headline">¶</a></h2>
<p>We can introduce type parameters via <code class="docutils literal notranslate"><span class="pre">where</span></code> syntax.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@match</span> <span class="m">1</span> <span class="k">begin</span>
    <span class="nv">a</span> <span class="o">::</span> <span class="nv">T</span> <span class="nv">where</span> <span class="nv">T</span> <span class="o">=&gt;</span> <span class="nv">T</span>
<span class="k">end</span> <span class="c"># =&gt; Int64</span>
</pre></div>
</div>
<p>However, whenever you’re using <code class="docutils literal notranslate"><span class="pre">where</span></code>, DO NOT use locally captured type arguments in the right side of <code class="docutils literal notranslate"><span class="pre">::</span></code>, when <code class="docutils literal notranslate"><span class="pre">::</span></code> is directly under a <code class="docutils literal notranslate"><span class="pre">where</span></code>.</p>
<p><strong>Wrong use</strong>:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@match</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">))</span> <span class="k">begin</span>
    <span class="p">(</span><span class="o">::</span><span class="nv">T1</span> <span class="nv">where</span> <span class="nv">T1</span><span class="p">,</span> <span class="o">::</span><span class="nb">Tuple</span><span class="p">{</span><span class="nv">T1</span><span class="p">,</span> <span class="nv">T2</span><span class="p">}</span> <span class="nv">where</span> <span class="nv">T2</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nv">T1</span><span class="p">,</span> <span class="nv">T2</span><span class="p">)</span>
<span class="k">end</span>
<span class="c"># T1 not defined</span>
</pre></div>
</div>
<p>Workaround 1:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@match</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">))</span> <span class="k">begin</span>
    <span class="p">(</span><span class="o">::</span><span class="nv">T1</span> <span class="nv">where</span> <span class="nv">T1</span><span class="p">,</span> <span class="o">::</span><span class="nb">Tuple</span><span class="p">{</span><span class="nv">T1′</span><span class="p">,</span> <span class="nv">T2</span><span class="p">}</span> <span class="nv">where</span> <span class="p">{</span><span class="nv">T1′</span><span class="p">,</span> <span class="nv">T2</span><span class="p">})</span> <span class="o">&amp;&amp;</span>
     <span class="k">if</span> <span class="nv">T1′</span> <span class="o">==</span> <span class="nv">T1</span> <span class="k">end</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nv">T1</span><span class="p">,</span> <span class="nv">T2</span><span class="p">)</span>
<span class="k">end</span>
<span class="c"># (Int64, Int64)</span>
</pre></div>
</div>
<p>Workaround 2:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@match</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">))</span> <span class="k">begin</span>
    <span class="p">(</span><span class="o">::</span><span class="nv">T1</span><span class="p">,</span> <span class="p">(</span><span class="o">::</span><span class="nv">T1</span><span class="p">,</span> <span class="o">::</span><span class="nv">T2</span><span class="p">))</span> <span class="o">::</span> <span class="nb">Tuple</span><span class="p">{</span><span class="nv">T1</span><span class="p">,</span> <span class="nb">Tuple</span><span class="p">{</span><span class="nv">T1</span><span class="p">,</span> <span class="nv">T2</span><span class="p">}}</span> <span class="nv">where</span> <span class="p">{</span><span class="nv">T1</span><span class="p">,</span> <span class="nv">T2</span><span class="p">}</span> <span class="o">=&gt;</span>
        <span class="p">(</span><span class="nv">T1</span><span class="p">,</span> <span class="nv">T2</span><span class="p">)</span>
<span class="k">end</span>
<span class="c"># (Int64, Int64)</span>
</pre></div>
</div>
<p>Some other examples:</p>
<div class="highlight-julia-console notranslate"><div class="highlight"><pre><span></span><span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="m">1</span> <span class="k">begin</span>
           <span class="o">::</span><span class="nv">T</span> <span class="nv">where</span> <span class="nv">T</span> <span class="o">=&gt;</span> <span class="nv">T</span>
       <span class="k">end</span>
<span class="nb">Int64</span>

<span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="m">1</span> <span class="k">begin</span>
           <span class="o">::</span><span class="nv">T</span> <span class="nv">where</span> <span class="nv">T</span> <span class="o">&lt;:</span> <span class="nb">Number</span> <span class="o">=&gt;</span> <span class="nv">T</span>
       <span class="k">end</span>
<span class="nb">Int64</span>

<span class="gp">julia&gt;</span> <span class="nd">@match</span> <span class="m">1</span> <span class="k">begin</span>
           <span class="o">::</span><span class="nv">T</span> <span class="nv">where</span> <span class="nv">T</span> <span class="o">&lt;:</span> <span class="nb">AbstractFloat</span> <span class="o">=&gt;</span> <span class="nv">T</span>
       <span class="k">end</span>
<span class="nv">ERROR</span><span class="o">:</span> <span class="nv">matching</span> <span class="nv">non</span><span class="o">-</span><span class="nv">exhaustive</span><span class="p">,</span> <span class="nv">at</span> <span class="cm">#= REPL[n]:1 =#</span>
</pre></div>
</div>
</div>
<div class="section" id="do-patterns-many-patterns">
<h2>Do-Patterns &amp; Many-Patterns<a class="headerlink" href="#do-patterns-many-patterns" title="Permalink to this headline">¶</a></h2>
<p>To introduce side-effects into pattern matching, we provide a built-in pattern called <code class="docutils literal notranslate"><span class="pre">Do</span></code> pattern to achieve this.</p>
<p>Also, a pattern called <code class="docutils literal notranslate"><span class="pre">Many</span></code> can work with <code class="docutils literal notranslate"><span class="pre">Do</span></code> pattern in a perfect way.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@match</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">]</span> <span class="k">begin</span>
    <span class="nf">Many</span><span class="p">(</span><span class="o">::</span><span class="nb">Int</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">true</span>
    <span class="nv">_</span> <span class="o">=&gt;</span> <span class="k">false</span>
<span class="k">end</span> <span class="c"># true</span>

<span class="nd">@match</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span>  <span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="p">:</span><span class="nv">a</span><span class="p">,</span> <span class="p">:</span><span class="nv">b</span><span class="p">,</span> <span class="p">:</span><span class="nv">c</span><span class="p">]</span> <span class="k">begin</span>
    <span class="nf">Do</span><span class="p">(</span><span class="nv">count</span> <span class="o">=</span> <span class="m">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="nv">Many</span><span class="p">[</span>
        <span class="nv">a</span><span class="o">::</span><span class="nb">Int</span> <span class="o">&amp;&amp;</span> <span class="nf">Do</span><span class="p">(</span><span class="nv">count</span> <span class="o">=</span> <span class="nv">count</span> <span class="o">+</span> <span class="nv">a</span><span class="p">)</span> <span class="o">||</span>
        <span class="o">::</span><span class="nb">String</span>                        <span class="o">||</span>
        <span class="o">::</span><span class="nb">Symbol</span> <span class="o">&amp;&amp;</span> <span class="nf">Do</span><span class="p">(</span><span class="nv">count</span> <span class="o">=</span> <span class="nv">count</span> <span class="o">+</span> <span class="m">1</span><span class="p">)</span>
    <span class="p">]</span> <span class="o">=&gt;</span> <span class="nv">count</span>
<span class="k">end</span> <span class="c"># 9</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Do</span></code> and <code class="docutils literal notranslate"><span class="pre">Many</span></code> may be not used very often but quite convenient for some specific domain.</p>
<p><strong>P.S 1</strong>: when assigning variables with <code class="docutils literal notranslate"><span class="pre">Do</span></code>, don’t do <code class="docutils literal notranslate"><span class="pre">Do((x,</span> <span class="pre">y)</span> <span class="pre">=</span> <span class="pre">expr)</span></code>, use this: <code class="docutils literal notranslate"><span class="pre">Do(x</span> <span class="pre">=</span> <span class="pre">expr[1],</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">expr[2])</span></code>. Our pattern compile needs to aware the scope change!</p>
<p><strong>P.S 2</strong>: <code class="docutils literal notranslate"><span class="pre">Do[x...]</span></code> is an eye candy for <code class="docutils literal notranslate"><span class="pre">Do(x)</span></code>, and so does <code class="docutils literal notranslate"><span class="pre">Many[x]</span></code> for <code class="docutils literal notranslate"><span class="pre">Many(x)</span></code>. <strong>HOWEVER</strong>, do not use <code class="docutils literal notranslate"><span class="pre">begin</span> <span class="pre">end</span></code> syntax in <code class="docutils literal notranslate"><span class="pre">Do[...]</span></code> or <code class="docutils literal notranslate"><span class="pre">Many[...]</span></code>. Julia restricts the parser and it’ll not get treated as a <code class="docutils literal notranslate"><span class="pre">begin</span> <span class="pre">end</span></code> block.</p>
<p><strong>P.S 3</strong>: The <a class="reference external" href="#let-patterns"><code class="docutils literal notranslate"><span class="pre">let</span></code> pattern</a> is different from the <code class="docutils literal notranslate"><span class="pre">Do</span></code> pattern.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Do[x=y]</span></code> changes <code class="docutils literal notranslate"><span class="pre">x</span></code>, but <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span> <span class="pre">end</span></code> shadows <code class="docutils literal notranslate"><span class="pre">x</span></code>. <code class="docutils literal notranslate"><span class="pre">let</span></code> may also change a variable’s value. Check the documents of <code class="docutils literal notranslate"><span class="pre">&#64;switch</span></code> macro.</p></li>
<li><p>You can write non-binding in <code class="docutils literal notranslate"><span class="pre">Do</span></code>: <code class="docutils literal notranslate"><span class="pre">Do[println(1)]</span></code>, but you cannot do this in <code class="docutils literal notranslate"><span class="pre">let</span></code> patterns.</p></li>
</ul>
</div>
<div class="section" id="let-patterns">
<h2>Let Patterns<a class="headerlink" href="#let-patterns" title="Permalink to this headline">¶</a></h2>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@match</span> <span class="m">1</span> <span class="k">begin</span>
    <span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="m">1</span> <span class="k">end</span> <span class="o">=&gt;</span> <span class="nv">x</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Bind a variable without changing the value of existing variables, i.e., <code class="docutils literal notranslate"><span class="pre">let</span></code> patterns shadow symbols.</p>
<p><code class="docutils literal notranslate"><span class="pre">let</span></code> may also change a variable’s value. Check the documents of <code class="docutils literal notranslate"><span class="pre">&#64;switch</span></code> macro.</p>
</div>
<div class="section" id="active-patterns">
<h2>Active Patterns<a class="headerlink" href="#active-patterns" title="Permalink to this headline">¶</a></h2>
<p>This implementation is a subset of <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/active-patterns">F# Active Patterns</a>.</p>
<p>There’re 3 distinct active patterns, first of which is the normal form:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="c"># 1-ary deconstruction: return Union{Some{T}, Nothing}</span>
<span class="nd">@active</span> <span class="nf">LessThan0</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span> <span class="nv">x</span> <span class="o">&gt;=</span> <span class="m">0</span>
        <span class="k">nothing</span>
    <span class="k">else</span>
        <span class="nb">Some</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="nd">@match</span> <span class="m">15</span> <span class="k">begin</span>
    <span class="nf">LessThan0</span><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nv">a</span>
    <span class="nv">_</span> <span class="o">=&gt;</span> <span class="m">0</span>
<span class="k">end</span> <span class="c"># 0</span>

<span class="nd">@match</span> <span class="o">-</span><span class="m">15</span> <span class="k">begin</span>
    <span class="nf">LessThan0</span><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nv">a</span>
    <span class="nv">_</span> <span class="o">=&gt;</span> <span class="m">0</span>
<span class="k">end</span> <span class="c"># -15</span>

<span class="c"># 0-ary deconstruction: return Bool</span>
<span class="nd">@active</span> <span class="nf">IsLessThan0</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="k">begin</span>
    <span class="nv">x</span> <span class="o">&lt;</span> <span class="m">0</span>
<span class="k">end</span>

<span class="nd">@match</span> <span class="m">10</span> <span class="k">begin</span>
    <span class="nf">IsLessThan0</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="o">:</span><span class="nv">a</span>
    <span class="nv">_</span> <span class="o">=&gt;</span> <span class="o">:</span><span class="nv">b</span>
<span class="k">end</span> <span class="c"># b</span>

<span class="c"># (n+2)-ary deconstruction: return Tuple{E1, E2, ...}</span>
<span class="nd">@active</span> <span class="nf">SplitVecAt2</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="k">begin</span>
    <span class="p">(</span><span class="nv">x</span><span class="p">[</span><span class="m">1</span><span class="p">:</span><span class="m">2</span><span class="p">],</span> <span class="nv">x</span><span class="p">[</span><span class="m">2</span><span class="p">+</span><span class="m">1</span><span class="p">:</span><span class="nb">end</span><span class="p">])</span>
<span class="k">end</span>

<span class="nd">@match</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">7</span><span class="p">]</span> <span class="k">begin</span>
    <span class="nf">SplitVecAt2</span><span class="p">(</span><span class="nv">a</span><span class="p">,</span> <span class="nv">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nv">a</span><span class="p">,</span> <span class="nv">b</span><span class="p">)</span>
<span class="k">end</span>
<span class="c"># ([1, 2], [3, 4, 7])</span>
</pre></div>
</div>
<p>Above 3 cases can be enhanced by becoming <strong>parametric</strong>:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@active</span> <span class="nv">SplitVecAt</span><span class="p">{</span><span class="nv">N</span><span class="o">::</span><span class="nb">Int</span><span class="p">}(</span><span class="nv">x</span><span class="p">)</span> <span class="k">begin</span>
    <span class="p">(</span><span class="nv">x</span><span class="p">[</span><span class="m">1</span><span class="p">:</span><span class="nv">N</span><span class="p">],</span> <span class="nv">x</span><span class="p">[</span><span class="nv">N</span><span class="p">+</span><span class="m">1</span><span class="p">:</span><span class="nb">end</span><span class="p">])</span>
<span class="k">end</span>

<span class="nd">@match</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">7</span><span class="p">]</span> <span class="k">begin</span>
    <span class="nv">SplitVecAt</span><span class="p">{</span><span class="m">2</span><span class="p">}(</span><span class="nv">a</span><span class="p">,</span> <span class="nv">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nv">a</span><span class="p">,</span> <span class="nv">b</span><span class="p">)</span>
<span class="k">end</span>
<span class="c"># ([1, 2], [3, 4, 7])</span>

<span class="nd">@active</span> <span class="nv">Re</span><span class="p">{</span><span class="nv">r</span> <span class="o">::</span> <span class="nb">Regex</span><span class="p">}(</span><span class="nv">x</span><span class="p">)</span> <span class="k">begin</span>
    <span class="nv">res</span> <span class="o">=</span> <span class="nb">match</span><span class="p">(</span><span class="nv">r</span><span class="p">,</span> <span class="nv">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="nv">res</span> <span class="o">!==</span> <span class="k">nothing</span>
        <span class="c"># use explicit `if-else` to emphasize the return should be Union{T, Nothing}.</span>
        <span class="nb">Some</span><span class="p">(</span><span class="nv">res</span><span class="p">)</span>
    <span class="k">else</span>
        <span class="k">nothing</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="nd">@match</span> <span class="s">&quot;123&quot;</span> <span class="k">begin</span>
    <span class="nv">Re</span><span class="p">{</span><span class="sr">r&quot;\d+&quot;</span><span class="p">}(</span><span class="nv">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nv">x</span>
    <span class="nv">_</span> <span class="o">=&gt;</span> <span class="nd">@error</span> <span class="s">&quot;&quot;</span>
<span class="k">end</span> <span class="c"># RegexMatch(&quot;123&quot;)</span>
</pre></div>
</div>
<p>Sometimes the enum syntax is useful and convenient:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@active</span> <span class="nf">IsEven</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="k">begin</span>
    <span class="nv">x</span> <span class="o">%</span> <span class="m">2</span> <span class="o">===</span> <span class="m">0</span>
<span class="k">end</span>

<span class="nv">MLStyle</span><span class="p">.</span><span class="nf">is_enum</span><span class="p">(</span><span class="o">::</span><span class="nb">Type</span><span class="p">{</span><span class="nv">IsEven</span><span class="p">})</span> <span class="o">=</span> <span class="k">true</span>

<span class="nd">@match</span> <span class="m">6</span> <span class="k">begin</span>
    <span class="nv">IsEven</span> <span class="o">=&gt;</span> <span class="o">:</span><span class="nv">even</span>
    <span class="nv">_</span> <span class="o">=&gt;</span> <span class="o">:</span><span class="nv">odd</span>
<span class="k">end</span> <span class="c"># :even</span>
</pre></div>
</div>
</div>
<div class="section" id="expr-patterns">
<h2>Expr Patterns<a class="headerlink" href="#expr-patterns" title="Permalink to this headline">¶</a></h2>
<p>This is mainly for AST manipulations. In fact, another pattern informally called “Ast pattern”, would be translated into Expr patterns.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">function</span> <span class="nf">extract_name</span><span class="p">(</span><span class="nv">e</span><span class="p">)</span>
        <span class="nd">@match</span> <span class="nv">e</span> <span class="k">begin</span>
            <span class="o">::</span><span class="nb">Symbol</span>                           <span class="o">=&gt;</span> <span class="nv">e</span>
            <span class="nb">Expr</span><span class="p">(</span><span class="o">:&lt;:</span><span class="p">,</span> <span class="nv">a</span><span class="p">,</span> <span class="nv">_</span><span class="p">)</span>                    <span class="o">=&gt;</span> <span class="nf">extract_name</span><span class="p">(</span><span class="nv">a</span><span class="p">)</span>
            <span class="nb">Expr</span><span class="p">(</span><span class="o">:</span><span class="k">struct</span><span class="p">,</span> <span class="nv">_</span><span class="p">,</span> <span class="nv">name</span><span class="p">,</span> <span class="nv">_</span><span class="p">)</span>          <span class="o">=&gt;</span> <span class="nf">extract_name</span><span class="p">(</span><span class="nv">name</span><span class="p">)</span>
            <span class="nb">Expr</span><span class="p">(</span><span class="o">:</span><span class="nv">call</span><span class="p">,</span> <span class="nv">f</span><span class="p">,</span> <span class="nv">_</span><span class="p">...)</span>               <span class="o">=&gt;</span> <span class="nf">extract_name</span><span class="p">(</span><span class="nv">f</span><span class="p">)</span>
            <span class="nb">Expr</span><span class="p">(</span><span class="o">:</span><span class="p">.,</span> <span class="nv">subject</span><span class="p">,</span> <span class="nv">attr</span><span class="p">,</span> <span class="nv">_</span><span class="p">...)</span>      <span class="o">=&gt;</span> <span class="nf">extract_name</span><span class="p">(</span><span class="nv">subject</span><span class="p">)</span>
            <span class="nb">Expr</span><span class="p">(</span><span class="o">:</span><span class="k">function</span><span class="p">,</span> <span class="nv">sig</span><span class="p">,</span> <span class="nv">_</span><span class="p">...)</span>         <span class="o">=&gt;</span> <span class="nf">extract_name</span><span class="p">(</span><span class="nv">sig</span><span class="p">)</span>
            <span class="nb">Expr</span><span class="p">(</span><span class="o">:</span><span class="k">const</span><span class="p">,</span> <span class="nv">assn</span><span class="p">,</span> <span class="nv">_</span><span class="p">...)</span>           <span class="o">=&gt;</span> <span class="nf">extract_name</span><span class="p">(</span><span class="nv">assn</span><span class="p">)</span>
            <span class="nb">Expr</span><span class="p">(</span><span class="o">:</span><span class="p">(</span><span class="o">=</span><span class="p">),</span> <span class="nv">fn</span><span class="p">,</span> <span class="nv">body</span><span class="p">,</span> <span class="nv">_</span><span class="p">...)</span>         <span class="o">=&gt;</span> <span class="nf">extract_name</span><span class="p">(</span><span class="nv">fn</span><span class="p">)</span>
            <span class="nb">Expr</span><span class="p">(</span><span class="nv">expr_type</span><span class="p">,</span>  <span class="nv">_</span><span class="p">...)</span>             <span class="o">=&gt;</span> <span class="nb">error</span><span class="p">(</span><span class="s">&quot;Can&#39;t extract name from &quot;</span><span class="p">,</span>
                                                        <span class="nv">expr_type</span><span class="p">,</span> <span class="s">&quot; expression:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                                                        <span class="s">&quot;    </span><span class="si">$e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="k">end</span>
<span class="k">end</span>
<span class="nd">@assert</span> <span class="o">:</span><span class="nv">f</span> <span class="o">==</span> <span class="nf">extract_name</span><span class="p">(</span><span class="o">:</span><span class="p">(</span>
    <span class="k">function</span> <span class="nf">f</span><span class="p">()</span>
        <span class="m">1</span> <span class="o">+</span> <span class="m">1</span>
    <span class="k">end</span>
<span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="julia-code-as-expr-patterns">
<h2>Julia Code as Expr Patterns<a class="headerlink" href="#julia-code-as-expr-patterns" title="Permalink to this headline">¶</a></h2>
<p>For convenience I call this “AST pattern”, note it’s not a formal name.</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nv">rmlines</span> <span class="o">=</span> <span class="nd">@λ</span> <span class="k">begin</span>
    <span class="nv">e</span> <span class="o">::</span> <span class="nb">Expr</span>           <span class="o">-&gt;</span> <span class="nb">Expr</span><span class="p">(</span><span class="nv">e</span><span class="p">.</span><span class="nv">head</span><span class="p">,</span> <span class="nb">filter</span><span class="p">(</span><span class="nv">x</span> <span class="o">-&gt;</span> <span class="nv">x</span> <span class="o">!==</span> <span class="k">nothing</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="nv">rmlines</span><span class="p">,</span> <span class="nv">e</span><span class="p">.</span><span class="nv">args</span><span class="p">))...)</span>
      <span class="o">::</span> <span class="nb">LineNumberNode</span> <span class="o">-&gt;</span> <span class="k">nothing</span>
    <span class="nv">a</span>                   <span class="o">-&gt;</span> <span class="nv">a</span>
<span class="k">end</span>
<span class="nv">expr</span> <span class="o">=</span> <span class="k">quote</span>
    <span class="k">struct</span> <span class="nv">S</span><span class="p">{</span><span class="nv">T</span><span class="p">}</span>
        <span class="nv">a</span> <span class="o">::</span> <span class="nb">Int</span>
        <span class="nv">b</span> <span class="o">::</span> <span class="nv">T</span>
    <span class="k">end</span>
<span class="k">end</span> <span class="o">|&gt;</span> <span class="nv">rmlines</span>

<span class="nd">@match</span> <span class="nv">expr</span> <span class="k">begin</span>
    <span class="k">quote</span>
        <span class="k">struct</span> <span class="o">$</span><span class="nv">name</span><span class="p">{</span><span class="o">$</span><span class="nv">tvar</span><span class="p">}</span>
            <span class="o">$</span><span class="nv">f1</span> <span class="o">::</span> <span class="o">$</span><span class="nv">t1</span>
            <span class="o">$</span><span class="nv">f2</span> <span class="o">::</span> <span class="o">$</span><span class="nv">t2</span>
        <span class="k">end</span>
    <span class="k">end</span> <span class="o">=&gt;</span>
    <span class="k">quote</span>
        <span class="k">struct</span> <span class="o">$</span><span class="nv">name</span><span class="p">{</span><span class="o">$</span><span class="nv">tvar</span><span class="p">}</span>
            <span class="o">$</span><span class="nv">f1</span> <span class="o">::</span> <span class="o">$</span><span class="nv">t1</span>
            <span class="o">$</span><span class="nv">f2</span> <span class="o">::</span> <span class="o">$</span><span class="nv">t2</span>
        <span class="k">end</span>
    <span class="k">end</span> <span class="o">|&gt;</span> <span class="nv">rmlines</span> <span class="o">==</span> <span class="nv">expr</span>
<span class="k">end</span> <span class="c"># true</span>
</pre></div>
</div>
<p><strong>How you create an AST, then how you match them.</strong></p>
<p><strong>How you use AST interpolations(<code class="docutils literal notranslate"><span class="pre">$</span></code> operation), then how you use capturing patterns on them.</strong></p>
<p>The pattern <code class="docutils literal notranslate"><span class="pre">quote</span> <span class="pre">..</span> <span class="pre">end</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">:(begin</span> <span class="pre">...</span> <span class="pre">end)</span></code>.</p>
<p>Additionally, you can use any other patterns simultaneously when matching asts. In fact, there’re regular patterns inside a <code class="docutils literal notranslate"><span class="pre">$</span></code> expression of your ast pattern.</p>
<p>A more complex example presented here might help with your comprehension about this:</p>
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nv">ast</span> <span class="o">=</span> <span class="k">quote</span>
    <span class="k">function</span> <span class="nf">f</span><span class="p">(</span><span class="nv">a</span><span class="p">,</span> <span class="nv">b</span><span class="p">,</span> <span class="nv">c</span><span class="p">,</span> <span class="nv">d</span><span class="p">)</span>
      <span class="k">let</span> <span class="nv">d</span> <span class="o">=</span> <span class="nv">a</span> <span class="o">+</span> <span class="nv">b</span> <span class="o">+</span> <span class="nv">c</span><span class="p">,</span> <span class="nv">e</span> <span class="o">=</span> <span class="nv">x</span> <span class="o">-&gt;</span> <span class="m">2</span><span class="nv">x</span> <span class="o">+</span> <span class="nv">d</span>
          <span class="nf">e</span><span class="p">(</span><span class="nv">d</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="nd">@match</span> <span class="nv">ast</span> <span class="k">begin</span>
    <span class="k">quote</span>
        <span class="o">$</span><span class="p">(</span><span class="o">::</span><span class="nb">LineNumberNode</span><span class="p">)</span>

        <span class="k">function</span> <span class="o">$</span><span class="nf">funcname</span><span class="p">(</span>
            <span class="o">$</span><span class="nv">firstarg</span><span class="p">,</span>
            <span class="o">$</span><span class="p">(</span><span class="nv">args</span><span class="p">...),</span>
            <span class="o">$</span><span class="p">(</span><span class="nv">a</span> <span class="o">&amp;&amp;</span> <span class="k">if</span> <span class="nf">islowercase</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nv">a</span><span class="p">)[</span><span class="m">1</span><span class="p">])</span> <span class="k">end</span><span class="p">))</span>

            <span class="o">$</span><span class="p">(</span><span class="o">::</span><span class="nb">LineNumberNode</span><span class="p">)</span>
            <span class="k">let</span> <span class="o">$</span><span class="nv">bind_name</span> <span class="o">=</span> <span class="nv">a</span> <span class="o">+</span> <span class="nv">b</span> <span class="o">+</span> <span class="o">$</span><span class="nv">last_operand</span><span class="p">,</span> <span class="o">$</span><span class="p">(</span><span class="nv">other_bindings</span><span class="p">...)</span>
                <span class="o">$</span><span class="p">(</span><span class="o">::</span><span class="nb">LineNumberNode</span><span class="p">)</span>
                <span class="o">$</span><span class="nf">app_fn</span><span class="p">(</span><span class="o">$</span><span class="nv">app_arg</span><span class="p">)</span>
                <span class="o">$</span><span class="p">(</span><span class="nv">block1</span><span class="p">...)</span>
            <span class="k">end</span>

            <span class="o">$</span><span class="p">(</span><span class="nv">block2</span><span class="p">...)</span>
        <span class="k">end</span>
    <span class="k">end</span> <span class="o">&amp;&amp;</span> <span class="k">if</span> <span class="nb">isempty</span><span class="p">(</span><span class="nv">block1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nb">isempty</span><span class="p">(</span><span class="nv">block2</span><span class="p">)</span> <span class="k">end</span> <span class="o">=&gt;</span>

         <span class="nb">Dict</span><span class="p">(</span><span class="o">:</span><span class="nv">funcname</span> <span class="o">=&gt;</span> <span class="nv">funcname</span><span class="p">,</span>
              <span class="o">:</span><span class="nv">firstarg</span> <span class="o">=&gt;</span> <span class="nv">firstarg</span><span class="p">,</span>
              <span class="o">:</span><span class="nv">args</span>     <span class="o">=&gt;</span> <span class="nv">args</span><span class="p">,</span>
              <span class="o">:</span><span class="nv">last_operand</span> <span class="o">=&gt;</span> <span class="nv">last_operand</span><span class="p">,</span>
              <span class="o">:</span><span class="nv">other_bindings</span> <span class="o">=&gt;</span> <span class="nv">other_bindings</span><span class="p">,</span>
              <span class="o">:</span><span class="nv">app_fn</span>         <span class="o">=&gt;</span> <span class="nv">app_fn</span><span class="p">,</span>
              <span class="o">:</span><span class="nv">app_arg</span>        <span class="o">=&gt;</span> <span class="nv">app_arg</span><span class="p">)</span>
<span class="k">end</span>

<span class="c"># Dict{Symbol,Any} with 7 entries:</span>
<span class="c">#   :app_fn         =&gt; :e</span>
<span class="c">#   :args           =&gt; Any[:b, :c]</span>
<span class="c">#   :firstarg       =&gt; :a</span>
<span class="c">#   :funcname       =&gt; :f</span>
<span class="c">#   :other_bindings =&gt; Any[:(e = (x-&gt;begin…</span>
<span class="c">#   :last_operand   =&gt; :c</span>
<span class="c">#   :app_arg        =&gt; :d</span>
</pre></div>
</div>
<p>Here is several articles about Ast Patterns.</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.reddit.com/r/Julia/comments/ap4xwr/mlstylejl_a_modern_way_to_manipulate_asts/">A Modern Way to Manipulate ASTs</a>.</p></li>
<li><p><a class="reference external" href="https://discourse.julialang.org/t/an-elegant-and-efficient-way-to-extract-something-from-asts/19123">An Elegant and Efficient Way to Extract Something from ASTs</a>.</p></li>
</ul>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../_sources/syntax/pattern.md.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2020, thautwarm.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.1.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>